<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王也道长</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://luojiamingl.github.io/"/>
  <updated>2020-04-21T07:29:01.956Z</updated>
  <id>http://luojiamingl.github.io/</id>
  
  <author>
    <name>王也道长</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nginx下后端节点realserverweb健康检测模块ngx_http_upstream_check_module</title>
    <link href="http://luojiamingl.github.io/2020/04/21/nginx%E4%B8%8B%E5%90%8E%E7%AB%AF%E8%8A%82%E7%82%B9realserverweb%E5%81%A5%E5%BA%B7%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9D%97ngx_http_upstream_check_module/"/>
    <id>http://luojiamingl.github.io/2020/04/21/nginx下后端节点realserverweb健康检测模块ngx_http_upstream_check_module/</id>
    <published>2020-04-21T03:59:22.000Z</published>
    <updated>2020-04-21T07:29:01.956Z</updated>
    
    <content type="html"><![CDATA[<p>目前，nginx对后端节点健康检查的方式主要有3种，这里列出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、ngx_http_proxy_module 模块和ngx_http_upstream_module模块（自带）</span><br><span class="line">    官网地址：http://nginx.org/cn/docs/http/ngx_http_proxy_module.html#proxy_next_upstream</span><br><span class="line">2、nginx_upstream_check_module模块</span><br><span class="line">    官网网址：https://github.com/yaoweibin/nginx_upstream_check_module</span><br><span class="line">3、ngx_http_healthcheck_module模块</span><br><span class="line">    官网网址：http://wiki.nginx.org/NginxHttpHealthcheckModule</span><br></pre></td></tr></table></figure><p>公司业务线上对后端节点的健康检查是通过nginx_upstream_check_module模块做的，这里我将分别介绍这三种实现方式以及之间的差异性。</p><h2 id="一、ngx-http-proxy-module-模块和ngx-http-upstream-module模块（自带）"><a href="#一、ngx-http-proxy-module-模块和ngx-http-upstream-module模块（自带）" class="headerlink" title="一、ngx_http_proxy_module 模块和ngx_http_upstream_module模块（自带）"></a>一、ngx_http_proxy_module 模块和ngx_http_upstream_module模块（自带）</h2><p>严格来说，nginx自带是没有针对负载均衡后端节点的健康检查的，但是可以通过默认自带的ngx_http_proxy_module 模块和ngx_http_upstream_module模块中的相关指令来完成当后端节点出现故障时，自动切换到健康节点来提供访问。</p><p>这里列出这两个模块中相关的指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法: proxy_connect_timeout time;</span><br><span class="line">默认值:    proxy_connect_timeout 60s;</span><br><span class="line">上下文:    http, server, location</span><br></pre></td></tr></table></figure></p><p>ngx_http_proxy_module 模块中的 proxy_connect_timeout 指令、proxy_read_timeout指令和proxy_next_upstream指令.</p><p> 设置与后端服务器建立连接的超时时间。应该注意这个超时一般不可能大于75秒。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法: proxy_read_timeout time;</span><br><span class="line">默认值:    proxy_read_timeout 60s;</span><br><span class="line">上下文:    http, server, location</span><br></pre></td></tr></table></figure></p><p>定义从后端服务器读取响应的超时。此超时是指相邻两次读操作之间的最长时间间隔，而不是整个响应传输完成的最长时间。如果后端服务器在超时时间段内没有传输任何数据，连接将被关闭。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法: proxy_next_upstream error | timeout | invalid_header | http_500 | http_502 | http_503 | http_504 |http_404 | off ...;</span><br><span class="line">默认值:    proxy_next_upstream error timeout;</span><br><span class="line">上下文:    http, server, location</span><br></pre></td></tr></table></figure></p><p>指定在何种情况下一个失败的请求应该被发送到下一台后端服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">error      # 和后端服务器建立连接时，或者向后端服务器发送请求时，或者从后端服务器接收响应头时，出现错误</span><br><span class="line">timeout    # 和后端服务器建立连接时，或者向后端服务器发送请求时，或者从后端服务器接收响应头时，出现超时</span><br><span class="line">invalid_header  # 后端服务器返回空响应或者非法响应头</span><br><span class="line">http_500   # 后端服务器返回的响应状态码为500</span><br><span class="line">http_502   # 后端服务器返回的响应状态码为502</span><br><span class="line">http_503   # 后端服务器返回的响应状态码为503</span><br><span class="line">http_504   # 后端服务器返回的响应状态码为504</span><br><span class="line">http_404   # 后端服务器返回的响应状态码为404</span><br><span class="line">off        # 停止将请求发送给下一台后端服务器</span><br></pre></td></tr></table></figure><p>需要理解一点的是，只有在没有向客户端发送任何数据以前，将请求转给下一台后端服务器才是可行的。也就是说，如果在传输响应到客户端时出现错误或者超时，这类错误是不可能恢复的。</p><p>范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">proxy_next_upstream http_502 http_504 http_404 error timeout invalid_header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ngx_http_upstream_module模块中的server指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法: server address [parameters];</span><br><span class="line">默认值:    —</span><br><span class="line">上下文:    upstream</span><br></pre></td></tr></table></figure><p>范例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream name &#123;</span><br><span class="line">        server 10.1.1.110:8080 max_fails=1 fail_timeout=10s;</span><br><span class="line">        server 10.1.1.122:8080 max_fails=1 fail_timeout=10s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是每个指令的介绍：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">max_fails=number      # 设定Nginx与服务器通信的尝试失败的次数。在fail_timeout参数定义的时间段内，如果失败的次数达到此值，Nginx就认为服务器不可用。在下一个fail_timeout时间段，服务器不会再被尝试。 失败的尝试次数默认是1。设为0就会停止统计尝试次数，认为服务器是一直可用的。 你可以通过指令proxy_next_upstream、fastcgi_next_upstream和 memcached_next_upstream来配置什么是失败的尝试。 默认配置时，http_404状态不被认为是失败的尝试。</span><br><span class="line">fail_timeout=time       # 设定服务器被认为不可用的时间段以及统计失败尝试次数的时间段。在这段时间中，服务器失败次数达到指定的尝试次数，服务器就被认为不可用。默认情况下，该超时时间是10秒。</span><br><span class="line">       在实际应用当中，如果你后端应用是能够快速重启的应用，比如nginx的话，自带的模块是可以满足需求的。但是需要注意。如果后端有不健康节点，负载均衡器依然会先把该请求转发给该不健康节点，然后再转发给别的节点，这样就会浪费一次转发。</span><br><span class="line">       可是，如果当后端应用重启时，重启操作需要很久才能完成的时候就会有可能拖死整个负载均衡器。此时，由于无法准确判断节点健康状态，导致请求handle住，出现假死状态，最终整个负载均衡器上的所有节点都无法正常响应请求。由于公司的业务程序都是java开发的，因此后端主要是nginx集群和tomcat集群。由于tomcat重启应部署上面的业务不同，有些业务启动初始化时间过长，就会导致上述现象的发生，因此不是很建议使用该模式。</span><br><span class="line">       并且ngx_http_upstream_module模块中的server指令中的max_fails参数设置值，也会和ngx_http_proxy_module 模块中的的proxy_next_upstream指令设置起冲突。比如如果将max_fails设置为0，则代表不对后端服务器进行健康检查，这样还会使fail_timeout参数失效（即不起作用）。此时，其实我们可以通过调节ngx_http_proxy_module 模块中的 proxy_connect_timeout 指令、proxy_read_timeout指令，通过将他们的值调低来发现不健康节点，进而将请求往健康节点转移。</span><br><span class="line">       以上就是nginx自带的两个和后端健康检查相关的模块。</span><br></pre></td></tr></table></figure></p><h2 id="二、nginx-upstream-check-module模块"><a href="#二、nginx-upstream-check-module模块" class="headerlink" title="二、nginx_upstream_check_module模块"></a>二、nginx_upstream_check_module模块</h2><p>除了自带的上述模块，还有一个更专业的模块，来专门提供负载均衡器内节点的健康检查的。这个就是淘宝技术团队开发的 nginx 模块 nginx_upstream_check_module，通过它可以用来检测后端 realserver 的健康状态。如果后端 realserver 不可用，则所以的请求就不会转发到该节点上。</p><p>在淘宝自己的 tengine 上是自带了该模块的，大家可以访问淘宝tengine的官网来获取该版本的nginx，官方地址：<a href="http://tengine.taobao.org[/。](https://note.youdao.com/" target="_blank" rel="noopener">http://tengine.taobao.org[/。](https://note.youdao.com/</a>)</p><p>如果我们没有使用淘宝的 tengine 的话，可以通过补丁的方式来添加该模块到我们自己的 nginx 中。我们业务线上就是采用该方式进行添加的。</p><p>下面是部署流程！</p><h3 id="1、下载nginx-upstream-check-module模块"><a href="#1、下载nginx-upstream-check-module模块" class="headerlink" title="1、下载nginx_upstream_check_module模块"></a>1、下载nginx_upstream_check_module模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd /usr/local/src</span><br><span class="line">wget https://codeload.github.com/yaoweibin/nginx_upstream_check_module/zip/master</span><br><span class="line">unzip master</span><br><span class="line">[root@localhost /usr/local/src]# ll -d nginx_upstream_check_module-master</span><br><span class="line">drwxr-xr-x. 6 root root 4096 Dec  1 02:28 nginx_upstream_check_module-master</span><br></pre></td></tr></table></figure><h3 id="2、为nginx打补丁"><a href="#2、为nginx打补丁" class="headerlink" title="2、为nginx打补丁"></a>2、为nginx打补丁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /usr/local/src]# cd nginx-1.6.0 # 进入nginx的源码目录</span><br><span class="line">[root@localhost nginx-1.6.0]# patch -p1 &amp;lt; ../nginx_upstream_check_module-master/check_1.5.12+.patch</span><br><span class="line">[root@localhost nginx-1.6.0]# ./configure --user=nginx --group=nginx --prefix=/usr/local/nginx-1.6.0 --with-http_ssl_module --with-openssl=/usr/local/src/openssl-0.9.8q --with-pcre=/usr/local/src/pcre-8.32 --add-module=/usr/local/src/nginx_concat_module/ --add-module=../nginx_upstream_check_module-master/</span><br><span class="line">make (注意：此处只make，编译参数需要和之前的一样)</span><br><span class="line">[root@localhost nginx-1.6.0]# mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx-1.6.0.bak</span><br><span class="line">[root@localhost nginx-1.6.0]# cp ./objs/nginx /usr/local/nginx/sbin/</span><br><span class="line">[root@localhost nginx-1.6.0]# /usr/local/nginx/sbin/nginx -t  # 检查下是否有问题</span><br><span class="line">[root@localhost nginx-1.6.0]# kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`</span><br></pre></td></tr></table></figure><h3 id="3、在nginx-conf配置文件里面的upstream加入健康检查，如下："><a href="#3、在nginx-conf配置文件里面的upstream加入健康检查，如下：" class="headerlink" title="3、在nginx.conf配置文件里面的upstream加入健康检查，如下："></a>3、在nginx.conf配置文件里面的upstream加入健康检查，如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream name &#123;</span><br><span class="line">       server 192.168.0.21:80;</span><br><span class="line">       server 192.168.0.22:80;</span><br><span class="line">       check interval=3000 rise=2 fall=5 timeout=1000 type=http;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面配置的意思是，对name这个负载均衡条目中的所有节点，每个3秒检测一次，请求2次正常则标记 realserver状态为up，如果检测 5 次都失败，则标记 realserver的状态为down，超时时间为1秒。</p><p>这里列出nginx_upstream_check_module模块所支持的指令意思：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: check interval=milliseconds [fall=count] [rise=count] [timeout=milliseconds] [default_down=true|false] [type=tcp|http|ssl_hello|mysql|ajp] [port=check_port]</span><br><span class="line">Default: 如果没有配置参数，默认值是：interval=30000 fall=5 rise=2 timeout=1000 default_down=true type=tcp</span><br><span class="line">Context: upstream</span><br></pre></td></tr></table></figure></p><p>该指令可以打开后端服务器的健康检查功能。</p><p>指令后面的参数意义是：</p><pre><code>- interval：向后端发送的健康检查包的间隔。- fall(fall_count): 如果连续失败次数达到fall_count，服务器就被认为是down。- rise(rise_count): 如果连续成功次数达到rise_count，服务器就被认为是up。- timeout: 后端健康请求的超时时间。- default_down: 设定初始时服务器的状态，如果是true，就说明默认是down的，如果是false，就是up的。默认值是true，也就是一开始服务器认为是不可用，要等健康检查包达到一定成功次数以后才会被认为是健康的。- type：健康检查包的类型，现在支持以下多种类型- tcp：简单的tcp连接，如果连接成功，就说明后端正常。- ssl_hello：发送一个初始的SSL hello包并接受服务器的SSL hello包。- http：发送HTTP请求，通过后端的回复包的状态来判断后端是否存活。- mysql: 向mysql服务器连接，通过接收服务器的greeting包来判断后端是否存活。- ajp：向后端发送AJP协议的Cping包，通过接收Cpong包来判断后端是否存活。- port: 指定后端服务器的检查端口。你可以指定不同于真实服务的后端服务器的端口，比如后端提供的是443端口的应用，你可以去检查80端口的状态来判断后端健康状况。默认是0，表示跟后端server提供真实服务的端口一样。该选项出现于Tengine-1.4.0。</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: check_keepalive_requests request_num</span><br><span class="line">Default: 1</span><br><span class="line">Context: upstream</span><br></pre></td></tr></table></figure><p>该指令可以配置一个连接发送的请求数，其默认值为1，表示Tengine完成1次请求后即关闭连接。</p><p>Syntax: check_http_send http_packet<br>Default: “GET / HTTP/1.0\r\n\r\n”<br>Context: upstream<br>该指令可以配置http健康检查包发送的请求内容。为了减少传输数据量，推荐采用”HEAD”方法。</p><p>当采用长连接进行健康检查时，需在该指令中添加keep-alive请求头，如：”HEAD / HTTP/1.1\r\nConnection: keep-alive\r\n\r\n”。 同时，在采用”GET”方法的情况下，请求uri的size不宜过大，确保可以在1个interval内传输完成，否则会被健康检查模块视为后端服务器或网络异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: check_http_expect_alive [ http_2xx | http_3xx | http_4xx | http_5xx ]</span><br><span class="line">Default: http_2xx | http_3xx</span><br><span class="line">Context: upstream</span><br></pre></td></tr></table></figure></p><p>该指令指定HTTP回复的成功状态，默认认为2XX和3XX的状态是健康的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: check_shm_size size</span><br><span class="line">Default: 1M</span><br><span class="line">Context: http</span><br></pre></td></tr></table></figure></p><p>所有的后端服务器健康检查状态都存于共享内存中，该指令可以设置共享内存的大小。默认是1M，如果你有1千台以上的服务器并在配置的时候出现了错误，就可能需要扩大该内存的大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: check_status [html|csv|json]</span><br><span class="line">Default: check_status html</span><br><span class="line">Context: location</span><br></pre></td></tr></table></figure></p><p>显示服务器的健康状态页面。该指令需要在http块中配置。<br>在Tengine-1.4.0以后，你可以配置显示页面的格式。支持的格式有: html、csv、 json。默认类型是html。<br>你也可以通过请求的参数来指定格式，假设‘/status’是你状态页面的URL， format参数改变页面的格式，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/status?format=html</span><br><span class="line">/status?format=csv</span><br><span class="line">/status?format=json</span><br></pre></td></tr></table></figure></p><p>同时你也可以通过status参数来获取相同服务器状态的列表，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">/status?format=html&amp;amp;status=down</span><br><span class="line">/status?format=csv&amp;amp;status=up</span><br></pre></td></tr></table></figure></p><p>下面是一个状态也配置的范例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">      server &#123;</span><br><span class="line">            location /nstatus &#123;</span><br><span class="line">                   check_status;</span><br><span class="line">                   access_log off;</span><br><span class="line">                   #allow IP;</span><br><span class="line">                   #deny all;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>配置完毕后，重启nginx。此时通过访问定义好的路径，就可以看到当前 realserver 实时的健康状态啦。效果如下图：<br>realserver 都正常的状态：<br><img src="1.jpg" alt="image"></p><p>一台 realserver 故障的状态：</p><p><img src="2.jpg" alt="image"><br>OK，以上nginx_upstream_check_module模块的相关信息，更多的信息大家可以去该模块的淘宝tengine页面和github上该项目页面去查看，下面是访问地址：</p><p><a href="http://tengine.taobao.org/document_cn/http_upstream_check_cn.html" target="_blank" rel="noopener">http://tengine.taobao.org/document_cn/http_upstream_check_cn.html</a></p><p><a href="https://github.com/yaoweibin/nginx_upstream_check_module" target="_blank" rel="noopener">https://github.com/yaoweibin/nginx_upstream_check_module</a></p><p>在生产环境的实施应用中，需要注意的有 2 点：</p><p>1、主要定义好type。由于默认的type是tcp类型，因此假设你服务启动，不管是否初始化完毕，它的端口都会起来，所以此时前段负载均衡器为认为该服务已经可用，其实是不可用状态。</p><p>2、注意check_http_send值的设定。由于它的默认值是”GET / HTTP/1.0\r\n\r\n”。假设你的应用是通过<a href="http://ip/name访问的，那么这里你的check_http_send值就需要更改为”GET" target="_blank" rel="noopener">http://ip/name访问的，那么这里你的check_http_send值就需要更改为”GET</a> /name HTTP/1.0\r\n\r\n”才可以。针对采用长连接进行检查的，这里增加keep-alive请求头，即”HEAD /name HTTP/1.1\r\nConnection: keep-alive\r\n\r\n”。如果你后端的tomcat是基于域名的多虚拟机，此时你需要通过check_http_send定义host，不然每次访问都是失败，范例：check_http_send “GET /mobileapi HTTP/1.0\r\n HOST www.redhat.sx\r\n\r\n”;</p><h2 id="三、ngx-http-healthcheck-module模块"><a href="#三、ngx-http-healthcheck-module模块" class="headerlink" title="三、ngx_http_healthcheck_module模块"></a>三、ngx_http_healthcheck_module模块</h2><p>除了上面两个模块，nginx官方在早期的时候还提供了一个 ngx_http_healthcheck_module 模块用来进行nginx后端节点的健康检查。nginx_upstream_check_module模块就是参照该模块的设计理念进行开发的，因此在使用和效果上都大同小异。但是需要注意的是，ngx_http_healthcheck_module 模块仅仅支持nginx的1.0.0版本，1.1.0版本以后都不支持了！因此，对于目前常见的生产环境上都不会去用了，这里仅仅留个纪念，给大家介绍下这个模块！</p><p>原文链接：<a href="http://www.21yunwei.com/archives/50871" target="_blank" rel="noopener">http://www.21yunwei.com/archives/50871</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前，nginx对后端节点健康检查的方式主要有3种，这里列出：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;sp
      
    
    </summary>
    
      <category term="linux" scheme="http://luojiamingl.github.io/categories/linux/"/>
    
      <category term="负载均衡" scheme="http://luojiamingl.github.io/categories/linux/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    
      <category term="linux" scheme="http://luojiamingl.github.io/tags/linux/"/>
    
      <category term="负载均衡" scheme="http://luojiamingl.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>查看linux中的TCP连接数</title>
    <link href="http://luojiamingl.github.io/2020/01/01/%E6%9F%A5%E7%9C%8Blinux%E4%B8%AD%E7%9A%84TCP%E8%BF%9E%E6%8E%A5%E6%95%B0/"/>
    <id>http://luojiamingl.github.io/2020/01/01/查看linux中的TCP连接数/</id>
    <published>2020-01-01T07:46:22.000Z</published>
    <updated>2020-01-02T03:32:44.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>一、查看哪些IP连接本机</p><p>netstat -an</p><p>二、查看TCP连接数</p><p>1)统计80端口连接数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat|grep -i &quot;80&quot;|wc -l</span><br></pre></td></tr></table></figure></p><p>2）统计httpd协议连接数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep httpd|wc -l</span><br></pre></td></tr></table></figure></p><p>3）、统计已连接上的，状态为“established<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -na|grep ESTABLISHED|wc -l</span><br></pre></td></tr></table></figure></p><p>4)、查出哪个IP地址连接最多,将其封了.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -na|grep ESTABLISHED|awk &#123;print $5&#125;|awk -F: &#123;print $1&#125;|sort|uniq -c|sort -r +0n</span><br><span class="line"></span><br><span class="line">netstat -na|grep SYN|awk &#123;print $5&#125;|awk -F: &#123;print $1&#125;|sort|uniq -c|sort -r +0n</span><br></pre></td></tr></table></figure></p><hr><p>1、查看apache当前并发访问数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an | grep ESTABLISHED | wc -l</span><br></pre></td></tr></table></figure></p><p>对比httpd.conf中MaxClients的数字差距多少。</p><p>2、查看有多少个进程数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep httpd|wc -l</span><br></pre></td></tr></table></figure></p><p>3、可以使用如下参数查看数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server-status?auto</span><br><span class="line"></span><br><span class="line">#ps -ef|grep httpd|wc -l</span><br><span class="line">1388</span><br></pre></td></tr></table></figure></p><p>统计httpd进程数，连个请求会启动一个进程，使用于Apache服务器。<br>表示Apache能够处理1388个并发请求，这个值Apache可根据负载情况自动调整。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#netstat -nat|grep -i &quot;80&quot;|wc -l</span><br><span class="line">4341</span><br></pre></td></tr></table></figure></p><p>netstat -an会打印系统当前网络链接状态，而grep -i “80”是用来提取与80端口有关的连接的，wc -l进行连接数统计。<br>最终返回的数字就是当前所有80端口的请求总数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#netstat -na|grep ESTABLISHED|wc -l</span><br><span class="line">376</span><br></pre></td></tr></table></figure></p><p>netstat -an会打印系统当前网络链接状态，而grep ESTABLISHED 提取出已建立连接的信息。 然后wc -l统计。<br>最终返回的数字就是当前所有80端口的已建立连接的总数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat||grep ESTABLISHED|wc -</span><br></pre></td></tr></table></figure></p><p>可查看所有建立连接的详细记录</p><p>查看Apache的并发请求数及其TCP连接状态：<br>　　Linux命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">netstat -n | awk &apos;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&apos;</span><br><span class="line"></span><br><span class="line">（</span><br><span class="line"></span><br><span class="line">netstat -n | awk ‘/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;’</span><br><span class="line">TIME_WAIT 8947</span><br></pre></td></tr></table></figure></p><p>等待足够的时间以确保远程TCP接收到连接中断请求的确认<br>FIN_WAIT1 15 等待远程TCP连接中断请求，或先前的连接中断请求的确认<br>FIN_WAIT2 1 从远程TCP等待连接中断请求<br>ESTABLISHED 55 代表一个打开的连接<br>SYN_RECV 21 再收到和发送一个连接请求后等待对方对连接请求的确认<br>CLOSING 2 没有任何连接状态<br>LAST_ACK 4 等待原来的发向远程TCP的连接中断请求的确认</p><p>TCP连接状态详解<br>LISTEN： 侦听来自远方的TCP端口的连接请求<br>SYN-SENT： 再发送连接请求后等待匹配的连接请求<br>SYN-RECEIVED：再收到和发送一个连接请求后等待对方对连接请求的确认<br>ESTABLISHED： 代表一个打开的连接<br>FIN-WAIT-1： 等待远程TCP连接中断请求，或先前的连接中断请求的确认<br>FIN-WAIT-2： 从远程TCP等待连接中断请求<br>CLOSE-WAIT： 等待从本地用户发来的连接中断请求<br>CLOSING： 等待远程TCP对连接中断的确认<br>LAST-ACK： 等待原来的发向远程TCP的连接中断请求的确认<br>TIME-WAIT： 等待足够的时间以确保远程TCP接收到连接中断请求的确认<br>CLOSED： 没有任何连接状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　LAST_ACK 5</span><br><span class="line">　　SYN_RECV 30</span><br><span class="line">　　ESTABLISHED 1597</span><br><span class="line">　　FIN_WAIT1 51</span><br><span class="line">　　FIN_WAIT2 504</span><br><span class="line">　　TIME_WAIT 1057</span><br></pre></td></tr></table></figure></p><p>　　其中的<br>SYN_RECV表示正在等待处理的请求数；<br>ESTABLISHED表示正常数据传输状态；<br>TIME_WAIT表示处理完毕，等待超时结束的请求数。</p><hr><p>查看Apache并发请求数及其TCP连接状态</p><p>查看httpd进程数（即prefork模式下Apache能够处理的并发请求数）：<br>　　Linux命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep httpd | wc -l</span><br></pre></td></tr></table></figure></p><p>　　返回结果示例：<br>　　1388<br>　　表示Apache能够处理1388个并发请求，这个值Apache可根据负载情况自动调整，我这组服务器中每台的峰值曾达到过2002。</p><p>查看Apache的并发请求数及其TCP连接状态：<br>　　Linux命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n | awk &apos;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&apos;</span><br></pre></td></tr></table></figure></p><p>返回结果示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　LAST_ACK 5</span><br><span class="line">　　SYN_RECV 30</span><br><span class="line">　　ESTABLISHED 1597</span><br><span class="line">　　FIN_WAIT1 51</span><br><span class="line">　　FIN_WAIT2 504</span><br><span class="line">　　TIME_WAIT 1057</span><br></pre></td></tr></table></figure></p><p>　　其中的SYN_RECV表示正在等待处理的请求数；ESTABLISHED表示正常数据传输状态；TIME_WAIT表示处理完毕，等待超时结束的请求数。<br>　　状态：描述</p><p>　　CLOSED：无连接是活动 的或正在进行</p><p>　　LISTEN：服务器在等待进入呼叫</p><p>　　SYN_RECV：一个连接请求已经到达，等待确认</p><p>　　SYN_SENT：应用已经开始，打开一个连接</p><p>　　ESTABLISHED：正常数据传输状态</p><p>　　FIN_WAIT1：应用说它已经完成</p><p>　　FIN_WAIT2：另一边已同意释放</p><p>　　ITMED_WAIT：等待所有分组死掉</p><p>　　CLOSING：两边同时尝试关闭</p><p>　　TIME_WAIT：另一边已初始化一个释放</p><p>　　LAST_ACK：等待所有分组死掉</p><p>如发现系统存在大量TIME_WAIT状态的连接，通过调整内核参数解决，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysctl.conf</span><br></pre></td></tr></table></figure></p><p>编辑文件，加入以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br></pre></td></tr></table></figure></p><p>然后执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sbin/sysctl -p</span><br></pre></td></tr></table></figure></p><p>让参数生效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_syncookies = 1</span><br></pre></td></tr></table></figure></p><p>表示开启SYN cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；<br>net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；<br>net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。<br>net.ipv4.tcp_fin_timeout 修改系統默认的 TIMEOUT 时间</p><p>下面附上TIME_WAIT状态的意义：</p><p>客户端与服务器端建立TCP/IP连接后关闭SOCKET后，服务器端连接的端口<br>状态为TIME_WAIT</p><p>是不是所有执行主动关闭的socket都会进入TIME_WAIT状态呢？<br>有没有什么情况使主动关闭的socket直接进入CLOSED状态呢？</p><p>主动关闭的一方在发送最后一个 ack 后<br>就会进入 TIME_WAIT 状态 停留2MSL（max segment lifetime）时间<br>这个是TCP/IP必不可少的，也就是“解决”不了的。</p><p>也就是TCP/IP设计者本来是这么设计的<br>主要有两个原因<br>1。防止上一次连接中的包，迷路后重新出现，影响新连接<br>（经过2MSL，上一次连接中所有的重复包都会消失）<br>2。可靠的关闭TCP连接<br>在主动关闭方发送的最后一个 ack(fin) ，有可能丢失，这时被动方会重新发<br>fin, 如果这时主动方处于 CLOSED 状态 ，就会响应 rst 而不是 ack。所以<br>主动方要处于 TIME_WAIT 状态，而不能是 CLOSED 。</p><p>TIME_WAIT 并不会占用很大资源的，除非受到攻击。</p><p>还有，如果一方 send 或 recv 超时，就会直接进入 CLOSED 状态</p><p>如何合理设置apache httpd的最大连接数？</p><p>手头有一个网站在线人数增多，访问时很慢。初步认为是服务器资源不足了，但经反复测试，一旦连接上，不断点击同一个页面上不同的链接，都能迅速打开，这种现象就是说明apache最大连接数已经满了，新的访客只能排队等待有空闲的链接，而如果一旦连接上，在keeyalive 的存活时间内（KeepAliveTimeout，默认5秒）都不用重新打开连接，因此解决的方法就是加大apache的最大连接数。</p><p>1.在哪里设置？<br>apache 2.24，使用默认配置（FreeBSD 默认不加载自定义MPM配置），默认最大连接数是250</p><p>在/usr/local/etc/apache22/httpd.conf中加载MPM配置（去掉前面的注释）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Server-pool management (MPM specific)</span><br><span class="line"></span><br><span class="line">Include etc/apache22/extra/httpd-mpm.conf</span><br></pre></td></tr></table></figure></p><p>可见的MPM配置在/usr/local/etc/apache22/extra/httpd-mpm.conf，但里面根据httpd的工作模式分了很多块，哪一部才是当前httpd的工作模式呢？可通过执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apachectl -l</span><br></pre></td></tr></table></figure></p><p>来查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Compiled in modules:</span><br><span class="line">              core.c</span><br><span class="line">              prefork.c</span><br><span class="line">              http_core.c</span><br><span class="line">              mod_so.c</span><br></pre></td></tr></table></figure></p><p>看到prefork 字眼，因此可见当前httpd应该是工作在prefork模式，prefork模式的默认配置是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mpm_prefork_module&gt;</span><br><span class="line">                StartServers                      5</span><br><span class="line">                MinSpareServers                   5</span><br><span class="line">                MaxSpareServers                  10</span><br><span class="line">                MaxClients                      150</span><br><span class="line">                MaxRequestsPerChild               0</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure></p><p>2.要加到多少？</p><p>连接数理论上当然是支持越大越好，但要在服务器的能力范围内，这跟服务器的CPU、内存、带宽等都有关系。</p><p>查看当前的连接数可以用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep httpd | wc -l</span><br></pre></td></tr></table></figure></p><p>或：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pgrep httpd|wc -l</span><br></pre></td></tr></table></figure></p><p>计算httpd占用内存的平均数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep -v grep|awk &apos;/httpd/&#123;sum+=$6;n++&#125;;END&#123;print sum/n&#125;&apos;</span><br></pre></td></tr></table></figure></p><p>由于基本都是静态页面，CPU消耗很低，每进程占用内存也不算多，大约200K。</p><p>服务器内存有2G，除去常规启动的服务大约需要500M（保守估计），还剩1.5G可用，那么理论上可以支持1.5<em>1024</em>1024*1024/200000 = 8053.06368</p><p>约8K个进程，支持2W人同时访问应该是没有问题的（能保证其中8K的人访问很快，其他的可能需要等待1、2秒才能连上，而一旦连上就会很流畅）</p><p>控制最大连接数的MaxClients ，因此可以尝试配置为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mpm_prefork_module&gt;</span><br><span class="line">                StartServers                      5</span><br><span class="line">                MinSpareServers                   5</span><br><span class="line">                MaxSpareServers                  10</span><br><span class="line">                ServerLimit                    5500</span><br><span class="line">                MaxClients                     5000</span><br><span class="line">                MaxRequestsPerChild               100</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure></p><p>注意，MaxClients默认最大为250，若要超过这个值就要显式设置ServerLimit，且ServerLimit要放在MaxClients之前，值要不小于MaxClients，不然重启httpd时会有提示。</p><p>重启httpd后，通过反复执行pgrep httpd|wc -l 来观察连接数，可以看到连接数在达到MaxClients的设值后不再增加，但此时访问网站也很流畅，那就不用贪心再设置更高的值了，不然以后如果网站访问突增不小心就会耗光服务器内存，可根据以后访问压力趋势及内存的占用变化再逐渐调整，直到找到一个最优的设置值。</p><p>(MaxRequestsPerChild不能设置为0，可能会因内存泄露导致服务器崩溃）</p><p>更佳最大值计算的公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apache_max_process_with_good_perfermance &lt; (total_hardware_memory / apache_memory_per_process ) * 2</span><br><span class="line">apache_max_process = apache_max_process_with_good_perfermance * 1.5</span><br></pre></td></tr></table></figure></p><p>附：</p><p>实时检测HTTPD连接数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n 1 -d &quot;pgrep httpd|wc -l&quot;</span><br></pre></td></tr></table></figure></p><p>————————————————</p><p>原文链接：<a href="https://blog.csdn.net/he_jian1/article/details/40787269" target="_blank" rel="noopener">https://blog.csdn.net/he_jian1/article/details/40787269</a></p><h3 id="有问题可以联系博主。"><a href="#有问题可以联系博主。" class="headerlink" title="有问题可以联系博主。"></a><strong>有问题可以联系博主</strong>。</h3><h3 id="转载请注明出处，谢谢！"><a href="#转载请注明出处，谢谢！" class="headerlink" title="转载请注明出处，谢谢！"></a><strong>转载请注明出处，谢谢</strong>！</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;一、查看哪些IP连接本机&lt;/p&gt;
&lt;p&gt;netstat -an&lt;/p&gt;
&lt;p&gt;二、查看TCP连接数&lt;/p&gt;
&lt;p&gt;1)统计80端口连接数&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
      
    
    </summary>
    
      <category term="linux" scheme="http://luojiamingl.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://luojiamingl.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>提高性能，MySQL 读写分离环境搭建</title>
    <link href="http://luojiamingl.github.io/2019/08/30/%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%EF%BC%8CMySQL%20%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://luojiamingl.github.io/2019/08/30/提高性能，MySQL 读写分离环境搭建/</id>
    <published>2019-08-30T07:46:22.000Z</published>
    <updated>2019-08-30T08:36:44.439Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>MySQL 读写分离在互联网项目中应该算是一个非常常见的需求了。受困于 Linux 和 MySQL 版本问题，很多人经常会搭建失败，今天给大伙举一个成功的例子。</p><h1 id="CentOS-安装-MySQL"><a href="#CentOS-安装-MySQL" class="headerlink" title="CentOS 安装 MySQL"></a>CentOS 安装 MySQL</h1><p>环境：</p><p>CentOS7<br>MySQL5.7<br>具体的安装步骤如下：</p><p>检查是否安装了 mariadb，如果已经安装了则卸载：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list installed | grep mariadb</span><br></pre></td></tr></table></figure></p><p>如果执行结果如下，表示已经安装了 mariadb，将之卸载：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mariadb-libs.x86_64      1:5.5.52-1.el7      @anaconda</span><br></pre></td></tr></table></figure></p><p>卸载命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y remove mariadb*</span><br></pre></td></tr></table></figure></p><p>接下来下载官方提供的 rpm 包<br>如果 CentOS 上没有 wget 命令，首先通过如下命令安装 wget：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install wget</span><br></pre></td></tr></table></figure></p><p>然后执行如下操作下载 rpm 包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm</span><br></pre></td></tr></table></figure></p><p>下载完成后，安装rpm包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh mysql57-community-release-el7-11.noarch.rpm</span><br></pre></td></tr></table></figure></p><p>检查 MySQL 的 yum 源是否安装成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum repolist enabled | grep &quot;mysql.*-community.*&quot;</span><br></pre></td></tr></table></figure></p><p>执行结果如下表示安装成功：</p><p><img src="1.jpg" alt="image"></p><p>安装 MySQL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql-server</span><br></pre></td></tr></table></figure></p><p>安装完成后，启动MySQL：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld.service</span><br></pre></td></tr></table></figure></p><p>停止MySQL：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop mysqld.service</span><br></pre></td></tr></table></figure></p><p>登录 MySQL：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure></p><p>默认无密码。有的版本有默认密码，查看默认密码，首先去 /etc/my.cnf 目录下查看 MySQL 的日志位置，然后打开日志文件，可以看到日志中有一个提示，生成了一个临时的默认密码，使用这个密码登录，登录成功后修改密码即可。</p><p>改密码<br>首先修改密码策略(这一步不是必须的，如果不修改密码策略，需要取一个比较复杂的密码，松哥这里简单起见，就修改下密码策略)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global validate_password_policy=0;</span><br></pre></td></tr></table></figure></p><p>然后重置密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set password=password(&quot;123&quot;);</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></p><p>授权远程登录同方式一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;123&apos; with grant option;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></p><p>授权远程登录同方式二：<br>修改 mysql 库中的 user 表，将 root 用户的 Host 字段的值改为 % ，然后重启 MySQL 即可。</p><p>关闭防火墙 MySQL 要能远程访问，还需要关闭防火墙：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure></p><p>禁止firewall开机启动:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></table></figure></p><h1 id="MySQL-读写分离环境搭建。"><a href="#MySQL-读写分离环境搭建。" class="headerlink" title="MySQL 读写分离环境搭建。"></a>MySQL 读写分离环境搭建。</h1><p>准备工作</p><p>我这里有一张简单的图向大伙展示 MySQL 主从的工作方式：</p><p><img src="2.jpg" alt="image"></p><p>这里，我们准备两台机器：</p><p>主机：192.168.248.128 •从机：192.168.248.139</p><h2 id="主机配置"><a href="#主机配置" class="headerlink" title="主机配置"></a>主机配置</h2><p>主机的配置就三个步骤，比较容易：</p><p>1、授权给从机服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GRANT REPLICATION SLAVE ON *.* to &apos;rep1&apos;@&apos;192.168.248.139&apos; identified by &apos;123&apos;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure></p><p>这里表示配置从机登录用户名为 rep1，密码为 123，并且必须从 192.168.248.139这个地址登录，登录成功之后可以操作任意库中的任意表。其中，如果不需要限制登录地址，可以将 IP 地址更换为一个 %。</p><p>2.修改主库配置文件，开启 binlog ，并设置 server-id ，每次修改配置文件后都要重启 MySQL 服务才会生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/my.cnf</span><br></pre></td></tr></table></figure></p><p>修改的文件内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin=/var/lib/mysql/binlog</span><br><span class="line">server-id=128</span><br><span class="line">binlog-do-db = cmdb</span><br></pre></td></tr></table></figure></p><p>如下图：</p><p><img src="3.jpg" alt="image"></p><p>log-bin：同步的日志路径及文件名，一定注意这个目录要是 MySQL 有权限写入的（我这里是偷懒了，直接放在了下面那个datadir下面</p><p>binlog-do-db：要同步的数据库名，当从机连上主机后，只有这里配置的数据库才会被同步，其他的不会被同步</p><p>server-id: MySQL 在主从环境下的唯一标志符，给个任意数字，注意不能和从机重复。</p><p>配置完成后重启 MySQL 服务端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure></p><p>3、查看主服务器当前二进制日志名和偏移量，这个操作的目的是为了在从数据库启动后，从这个点开始进行数据的恢复：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure></p><p><img src="4.jpg" alt="image"></p><p>至此，主机配置完成。</p><h2 id="从机配置"><a href="#从机配置" class="headerlink" title="从机配置"></a>从机配置</h2><p>从机的配置也比较简单，我们一步一步来看：<br>1.在/etc/my.cnf 添加下面配置：</p><p><img src="5.jpg" alt="image"></p><p>注意从机这里只需要配置一下 server-id 即可。</p><p>注意：如果从机是从主机复制来的，即我们通过复制 CentOS 虚拟机获取了 MySQL 实例 ，此时两个 MySQL 的 uuid 一样（正常安装是不会相同的），这时需要手动修改，修改位置在 /var/lib/mysql/auto.cnf ，注意随便修改这里几个字符即可，但也不可太过于随意，例如修改了 uuid 的长度。</p><p>2.使用命令来配置从机：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">change master to master_host=&apos;192.168.248.128&apos;,master_port=3306,master_user=&apos;rep1&apos;,master_password=&apos;123&apos;,master_log_file=&apos;binlog.000001&apos;,master_log_pos=120;</span><br></pre></td></tr></table></figure></p><p>这里配置了主机地址、端口以及从机登录主机的用户名和密码，注意最后两个参数要和 master 中的保持一致。</p><p>3.启动 slave 进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure></p><p>启动之后查看从机状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show slave status\G;</span><br></pre></td></tr></table></figure></p><p><img src="6.jpg" alt="image"></p><p>4.查看 slave 的状态</p><p>主要是下面两项值都要为为 YES，则表示配置正确：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Slave_IO_Running: Yes</span><br><span class="line">Slave_SQL_Running: Yes</span><br></pre></td></tr></table></figure></p><p>至此，配置完成，主机创建库，添加数据，从机会自动同步。</p><p>如果这两个有一个不为 YES ，表示主从环境搭建失败，此时可以阅读日志，查看出错的原因，再具体问题具体解决。</p><p>原文链接：<a href="https://mp.weixin.qq.com/s/QapdsWt5KOi1L0JKX4B0pg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/QapdsWt5KOi1L0JKX4B0pg</a></p><h3 id="转载请注明出处，谢谢！"><a href="#转载请注明出处，谢谢！" class="headerlink" title="转载请注明出处，谢谢！"></a><strong>转载请注明出处，谢谢</strong>！</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;MySQL 读写分离在互联网项目中应该算是一个非常常见的需求了。受困于 Linux 和 MySQL 版本问题，很多人经常会搭建失败，今天给大伙举一个成功的例子。&lt;/p&gt;
&lt;h1 id=&quot;CentOS-安装-MySQL&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="mysql" scheme="http://luojiamingl.github.io/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://luojiamingl.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ之VirtualTopic</title>
    <link href="http://luojiamingl.github.io/2019/06/17/ActiveMQ%E4%B9%8BVirtualTopic%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://luojiamingl.github.io/2019/06/17/ActiveMQ之VirtualTopic是什么/</id>
    <published>2019-06-17T07:46:22.000Z</published>
    <updated>2019-06-17T07:42:34.420Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>一句话总结： VirtualTopic是为了解决持久化模式下多消费端同时接收同一条消息的问题。</p><p>Topic订阅模式缺点，虽然满足1对多同时接收，然而持久化模式下只能有一个持有clientID的消费者连接，不满足持久化需求</p><p>简单说来，就是将Topic和Queue相结合，各取所长。</p><p>VirtualTopic 就是这样一种存在，对生产者而言它是Topic，对消费者而言它是Queue，内部的处理机制就是由Broker将接收到的消息二次分发给每一个Queue，然后由不同的Queue对应不同的应用实现持久化，不同的消费端只关心并连接到自己的Queue接收消息即可。</p><p><img src="mq.png" alt="image"></p><p>VirtualTopic 因为不同消费者会同事收到所有消息，所以会存在重复消费的问题，如果业务上要求只消费一次，需要在业务上做幂等处理。</p><p>总结一下：</p><ol><li>虚拟Topic是一种特殊命名的Topic，系统根据命名规则将该Topic内的消息分发给当前存在的名称对应的Queue，分发是非持久化的，新加入的Queue是接收不到过去的消息的。</li><li>虚拟Topic还是Topic，不是什么新的存在，具有普通Topic的所有功能，只是名字特殊而已。</li><li>虚拟Topic的功能完全是中间件本身额外附加的机制，对于生产者和消费者都是无感知的。</li><li>对于运维人员来说，还是正常监控队列即可，虚拟Topic是非持久化的，不存在积压。</li></ol><h3 id="有问题可以联系博主。"><a href="#有问题可以联系博主。" class="headerlink" title="有问题可以联系博主。"></a><strong>有问题可以联系博主</strong>。</h3><h3 id="转载请注明出处，谢谢！"><a href="#转载请注明出处，谢谢！" class="headerlink" title="转载请注明出处，谢谢！"></a><strong>转载请注明出处，谢谢</strong>！</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;一句话总结： VirtualTopic是为了解决持久化模式下多消费端同时接收同一条消息的问题。&lt;/p&gt;
&lt;p&gt;Topic订阅模式缺点，虽然满足1对多同时接收，然而持久化模式下只能有一个持有clientID的消费者连接，不满足持久化需求&lt;/
      
    
    </summary>
    
      <category term="MQ" scheme="http://luojiamingl.github.io/categories/MQ/"/>
    
      <category term="消息队列" scheme="http://luojiamingl.github.io/categories/MQ/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="MQ" scheme="http://luojiamingl.github.io/tags/MQ/"/>
    
      <category term="消息队列" scheme="http://luojiamingl.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>RestController和Controller区别</title>
    <link href="http://luojiamingl.github.io/2019/05/08/RestController%E5%92%8CController%E5%8C%BA%E5%88%AB/"/>
    <id>http://luojiamingl.github.io/2019/05/08/RestController和Controller区别/</id>
    <published>2019-05-08T07:46:22.000Z</published>
    <updated>2019-05-08T09:08:51.301Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="RestController注解相当于-ResponseBody-＋-Controller合在一起的作用。"><a href="#RestController注解相当于-ResponseBody-＋-Controller合在一起的作用。" class="headerlink" title="@RestController注解相当于@ResponseBody ＋ @Controller合在一起的作用。"></a>@RestController注解相当于@ResponseBody ＋ @Controller合在一起的作用。</h3><h3 id="RestController使用的效果是将方法返回的对象直接在浏览器上展示成json格式，而如果单单使用-Controller会报错，需要ResponseBody配合使用。"><a href="#RestController使用的效果是将方法返回的对象直接在浏览器上展示成json格式，而如果单单使用-Controller会报错，需要ResponseBody配合使用。" class="headerlink" title="RestController使用的效果是将方法返回的对象直接在浏览器上展示成json格式，而如果单单使用@Controller会报错，需要ResponseBody配合使用。"></a>RestController使用的效果是将方法返回的对象直接在浏览器上展示成json格式，而如果单单使用@Controller会报错，需要ResponseBody配合使用。</h3><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="1、如果只是使用-RestController注解Controller类，则方法无法返回jsp页面，配置的视图解析器InternalResourceViewResolver不起作用，返回的内容就是Return-里的内容。"><a href="#1、如果只是使用-RestController注解Controller类，则方法无法返回jsp页面，配置的视图解析器InternalResourceViewResolver不起作用，返回的内容就是Return-里的内容。" class="headerlink" title="1、如果只是使用@RestController注解Controller类，则方法无法返回jsp页面，配置的视图解析器InternalResourceViewResolver不起作用，返回的内容就是Return 里的内容。"></a>1、如果只是使用@RestController注解Controller类，则方法无法返回jsp页面，配置的视图解析器InternalResourceViewResolver不起作用，返回的内容就是Return 里的内容。</h3><h3 id="例如：本来应该到success-jsp页面的，则其显示success"><a href="#例如：本来应该到success-jsp页面的，则其显示success" class="headerlink" title="例如：本来应该到success.jsp页面的，则其显示success."></a>例如：本来应该到success.jsp页面的，则其显示success.</h3><h3 id="2、如果需要返回到指定页面，则需要用-Controller配合视图解析器InternalResourceViewResolver才行。"><a href="#2、如果需要返回到指定页面，则需要用-Controller配合视图解析器InternalResourceViewResolver才行。" class="headerlink" title="2、如果需要返回到指定页面，则需要用 @Controller配合视图解析器InternalResourceViewResolver才行。"></a>2、如果需要返回到指定页面，则需要用 @Controller配合视图解析器InternalResourceViewResolver才行。</h3><h3 id="3、如果需要返回JSON，XML或自定义mediaType内容到页面，则需要在对应的方法上加上-ResponseBody注解。"><a href="#3、如果需要返回JSON，XML或自定义mediaType内容到页面，则需要在对应的方法上加上-ResponseBody注解。" class="headerlink" title="3、如果需要返回JSON，XML或自定义mediaType内容到页面，则需要在对应的方法上加上@ResponseBody注解。"></a>3、如果需要返回JSON，XML或自定义mediaType内容到页面，则需要在对应的方法上加上@ResponseBody注解。</h3><h3 id="有问题可以联系博主。"><a href="#有问题可以联系博主。" class="headerlink" title="有问题可以联系博主。"></a><strong>有问题可以联系博主</strong>。</h3><h3 id="转载请注明出处，谢谢！"><a href="#转载请注明出处，谢谢！" class="headerlink" title="转载请注明出处，谢谢！"></a><strong>转载请注明出处，谢谢</strong>！</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;RestController注解相当于-ResponseBody-＋-Controller合在一起的作用。&quot;&gt;&lt;a href=&quot;#RestController注解相当于-ResponseBody-＋-Controller合在一起
      
    
    </summary>
    
      <category term="spring" scheme="http://luojiamingl.github.io/categories/spring/"/>
    
    
      <category term="spring" scheme="http://luojiamingl.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>yum安装更新java sdk</title>
    <link href="http://luojiamingl.github.io/2019/05/06/yum%E5%AE%89%E8%A3%85%E6%9B%B4%E6%96%B0java%20sdk/"/>
    <id>http://luojiamingl.github.io/2019/05/06/yum安装更新java sdk/</id>
    <published>2019-05-06T07:46:22.000Z</published>
    <updated>2019-05-21T08:59:39.251Z</updated>
    
    <content type="html"><![CDATA[<p>安装之前先检查一下系统有没有自带open-jdk<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa |grep java </span><br><span class="line">rpm -qa |grep jdk </span><br><span class="line">rpm -qa |grep gcj</span><br></pre></td></tr></table></figure></p><p>如果没有输入信息表示没有安装。<br>如果安装可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep java | xargs rpm -e –nodeps</span><br></pre></td></tr></table></figure></p><p>(报错失败也无所谓 可以直接跳过)</p><p>批量卸载所有带有Java的文件 这句命令的关键字是java<br>首先检索包含java的列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list java*</span><br></pre></td></tr></table></figure></p><p>检索1.8的列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list java-1.8*</span><br></pre></td></tr></table></figure></p><p>安装1.8.0的所有文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install java-1.8.0-openjdk* -y</span><br></pre></td></tr></table></figure></p><p>使用命令检查是否安装成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure></p><p>到此安装结束了。这样安装有一个好处就是不需要对path进行设置，自动就设置好了</p><h3 id="有问题可以联系博主。"><a href="#有问题可以联系博主。" class="headerlink" title="有问题可以联系博主。"></a><strong>有问题可以联系博主</strong>。</h3><h3 id="转载请注明出处，谢谢！"><a href="#转载请注明出处，谢谢！" class="headerlink" title="转载请注明出处，谢谢！"></a><strong>转载请注明出处，谢谢</strong>！</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安装之前先检查一下系统有没有自带open-jdk&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="java" scheme="http://luojiamingl.github.io/categories/java/"/>
    
      <category term="linux" scheme="http://luojiamingl.github.io/categories/java/linux/"/>
    
    
      <category term="linux" scheme="http://luojiamingl.github.io/tags/linux/"/>
    
      <category term="java" scheme="http://luojiamingl.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>idea破解</title>
    <link href="http://luojiamingl.github.io/2019/05/06/IDEA%E7%A0%B4%E8%A7%A3/"/>
    <id>http://luojiamingl.github.io/2019/05/06/IDEA破解/</id>
    <published>2019-05-06T07:46:22.000Z</published>
    <updated>2019-05-06T12:38:45.459Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="破解方法"><a href="#破解方法" class="headerlink" title="破解方法"></a>破解方法</h1><p>license server</p><p>填写</p><p><a href="http://idea.toocruel.net/" target="_blank" rel="noopener">http://idea.toocruel.net/</a></p><p>简单粗暴搞定</p><h3 id="有问题可以联系博主。"><a href="#有问题可以联系博主。" class="headerlink" title="有问题可以联系博主。"></a><strong>有问题可以联系博主</strong>。</h3><h3 id="转载请注明出处，谢谢！"><a href="#转载请注明出处，谢谢！" class="headerlink" title="转载请注明出处，谢谢！"></a><strong>转载请注明出处，谢谢</strong>！</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;破解方法&quot;&gt;&lt;a href=&quot;#破解方法&quot; class=&quot;headerlink&quot; title=&quot;破解方法&quot;&gt;&lt;/a&gt;破解方法&lt;/h1&gt;&lt;p&gt;license server&lt;/p&gt;
&lt;p&gt;填写&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;htt
      
    
    </summary>
    
      <category term="软件破解" scheme="http://luojiamingl.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/"/>
    
    
      <category term="idea" scheme="http://luojiamingl.github.io/tags/idea/"/>
    
      <category term="软件破解" scheme="http://luojiamingl.github.io/tags/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>nginx添加ipv6模块并配置ipv6端口监听</title>
    <link href="http://luojiamingl.github.io/2018/12/20/nginx%E6%B7%BB%E5%8A%A0ipv6%E6%A8%A1%E5%9D%97%E5%B9%B6%E9%85%8D%E7%BD%AEipv6%E7%AB%AF%E5%8F%A3%E7%9B%91%E5%90%AC/"/>
    <id>http://luojiamingl.github.io/2018/12/20/nginx添加ipv6模块并配置ipv6端口监听/</id>
    <published>2018-12-20T03:59:22.000Z</published>
    <updated>2018-12-20T02:06:28.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一为Nginx添加ipv6模块"><a href="#一为Nginx添加ipv6模块" class="headerlink" title="一为Nginx添加ipv6模块"></a>一为Nginx添加ipv6模块</h1><h2 id="一：检查nginx是否已经包含ipv6模块"><a href="#一：检查nginx是否已经包含ipv6模块" class="headerlink" title="一：检查nginx是否已经包含ipv6模块"></a>一：检查nginx是否已经包含ipv6模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze3oyrjbxg32wecre15z /]# /alidata/server/nginx/sbin/nginx -V</span><br></pre></td></tr></table></figure><p><img src="1.png" alt="image"></p><p>从结果看出，输出结果没有 ipv6支持</p><p>如果支持ipv6，则输出结果会包含 “–with-ipv6”。<br><img src="2.png" alt="image"></p><p>如果各位同学的环境已经支持，则可以不用往下看啦！</p><h2 id="二：准备nginx源码"><a href="#二：准备nginx源码" class="headerlink" title="二：准备nginx源码"></a>二：准备nginx源码</h2><p>1、本文以1.4.4版本为例，其他版本没有测试，不过我想基本类似，具体请各位同学亲测。</p><p>2、如果本地没有源码，则需要到如下地址下载：<a href="http://nginx.org/download/nginx-1.4.4.tar.gz其他版本，也可以在http://nginx.org下载，上面会列出所有版本以供下载。" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.4.4.tar.gz其他版本，也可以在http://nginx.org下载，上面会列出所有版本以供下载。</a></p><p>3、将下载的源码上传到linux</p><p>在root 根目录新建 tmp目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze3oyrjbxg32wecre15z /]# cd /root</span><br><span class="line"></span><br><span class="line">[root@iz2ze3oyrjbxg32wecre15z /]# mkdir tmp</span><br></pre></td></tr></table></figure></p><p>将安装包上传到该目录，上传工具推荐同学们使用Xftp</p><h2 id="三：编译nginx源代码，加入ipv6支持"><a href="#三：编译nginx源代码，加入ipv6支持" class="headerlink" title="三：编译nginx源代码，加入ipv6支持"></a>三：编译nginx源代码，加入ipv6支持</h2><p>1、跳转到tmp目录，执行命令解压安装文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze3oyrjbxg32wecre15z /]# cd tmp</span><br><span class="line"></span><br><span class="line">[root@iz2ze3oyrjbxg32wecre15z /]# tar xvzf nginx-1.4.4.tar.gz</span><br></pre></td></tr></table></figure></p><p><img src="3.png" alt="image"></p><p>2、跳转到解压过后的目录，执行命令配置新的参数，加入 ipv6模块。</p><p>注意：在配置参数时，一定要在原来的参数的基础上追加，否则有可能丢失原来的支持模块，切记！切记！切记！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze3oyrjbxg32wecre15z /]# cd nginx-1.4.4</span><br><span class="line"></span><br><span class="line">[root@iz2ze3oyrjbxg32wecre15z/]#./configure --user=www --group=www --prefix=/alidata/server/nginx --with-http_stub_status_module --without-http-cache --with-http_ssl_module --with-http_gzip_static_module --with-ipv6</span><br></pre></td></tr></table></figure></p><p>注意：‘–’符号之间有空格。</p><p><img src="4.png" alt="image"></p><p>….中间省略若干输出<br><img src="5.png" alt="image"></p><p>3、配置完毕后，执行make 命令，重新编译</p><p><img src="6.png" alt="image"></p><p>….中间省略若干输出</p><p><img src="7.png" alt="image"></p><p>4、编译完毕后，会在当前目录下创建objs目录，新的nginx执行文件将生成在该目录中</p><p><img src="8.png" alt="image"></p><h2 id="四：替换nginx执行文件"><a href="#四：替换nginx执行文件" class="headerlink" title="四：替换nginx执行文件"></a>四：替换nginx执行文件</h2><p>1、同学们要养成好习惯，首先备份原来的nginx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze3oyrjbxg32wecre15z /]#</span><br><span class="line"></span><br><span class="line">cp /alidata/server/nginx/sbin/nginx /alidata/server/nginx/sbin/nginx.bak</span><br></pre></td></tr></table></figure></p><p>2、停止nginx</p><p>这里必须停止nginx，否则无法覆盖的哦！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze3oyrjbxg32wecre15z /]# service nginx stop</span><br></pre></td></tr></table></figure></p><p>3、覆盖nginx执行文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze3oyrjbxg32wecre15z /]# cp nginx /alidata/server/nginx/sbin/nginx</span><br></pre></td></tr></table></figure></p><p>3、测试新的nginx程序是否正确<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze3oyrjbxg32wecre15z /]# /alidata/server/nginx/sbin/nginx -t</span><br></pre></td></tr></table></figure></p><p>4、启动nginx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze3oyrjbxg32wecre15z /]# service nginx start</span><br></pre></td></tr></table></figure></p><p>五：再次检查nginx是否已经支持ipv6<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze3oyrjbxg32wecre15z /]# /alidata/server/nginx/sbin/nginx -V</span><br></pre></td></tr></table></figure></p><h1 id="二-配置IPv6端口监听"><a href="#二-配置IPv6端口监听" class="headerlink" title="二.配置IPv6端口监听"></a>二.配置IPv6端口监听</h1><p>Nginx可以同时支持ipv4与 ipv6的监听，但为了一致性的考虑，新版本Nginx推荐使用分开监听，下面我们开始进入正题。</p><h2 id="一、默认IPV4配置"><a href="#一、默认IPV4配置" class="headerlink" title="一、默认IPV4配置"></a>一、默认IPV4配置</h2><p>下面我们先来看一看默认的ipv4配置：</p><p><img src="9.png" alt="image"></p><h2 id="二、加入ipv6监听"><a href="#二、加入ipv6监听" class="headerlink" title="二、加入ipv6监听"></a>二、加入ipv6监听</h2><p>1、从Nginx 1.3的某个版本起，默认ipv6only是打开的，所以，我们只需要在监听中加入ipv6监听即可，不过推荐都手动加上比较好，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen [::]:80 ipv6only=on;</span><br></pre></td></tr></table></figure></p><p><img src="10.png" alt="image"></p><p>2、编辑完毕后保存，然后使用命令检测配置是否正确<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze3oyrjbxg32wecre15z /]# /alidata/server/nginx/sbin/nginx -t</span><br></pre></td></tr></table></figure></p><p><img src="11.png" alt="image"></p><p>如果出现 test is successful代表配置检测成功。</p><p> 3、重启nginx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze3oyrjbxg32wecre15z /]# service nginx reload</span><br></pre></td></tr></table></figure></p><h2 id="4、检测监听是否已经成功"><a href="#4、检测监听是否已经成功" class="headerlink" title="4、检测监听是否已经成功"></a>4、检测监听是否已经成功</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze3oyrjbxg32wecre15z /]# netstat -tuln</span><br></pre></td></tr></table></figure><p>如果列表出现 :::80的监听代表ipv6的监听已经成功。</p><h2 id="13三、其他个性化操作"><a href="#13三、其他个性化操作" class="headerlink" title="13三、其他个性化操作"></a>13三、其他个性化操作</h2><p>1、如果只想监听ipv6，则去掉ipv4的配置，然后将ipv6设置为默认即可。<br><img src="13.png" alt="image"></p><p>2、如果想监听指定ipv6地址，则将中括号中的::换成 指定ipv6地址即可。</p><p><img src="14.png" alt="image"></p><p>3、在前面的配置中，很多同学看到有监听443端口，这个是对ssl的监听，监听方式和默认80监听类似，大家可以举一反三嘛！</p><h2 id="四、我们使用ipv6网站来测试是否已经可以正常访问"><a href="#四、我们使用ipv6网站来测试是否已经可以正常访问" class="headerlink" title="四、我们使用ipv6网站来测试是否已经可以正常访问"></a>四、我们使用ipv6网站来测试是否已经可以正常访问</h2><p>我们常用的网站是：<a href="http://ipv6-test.com/validate.php" target="_blank" rel="noopener">http://ipv6-test.com/validate.php</a></p><p><img src="12.png" alt="image"></p><p>结果显示，已经正确访问到网站。</p><h3 id="转载请注明出处，谢谢！"><a href="#转载请注明出处，谢谢！" class="headerlink" title="转载请注明出处，谢谢！"></a><strong>转载请注明出处，谢谢</strong>！</h3><p>参考：<a href="https://blog.csdn.net/shenxianfeng/article/details/72859830！" target="_blank" rel="noopener">https://blog.csdn.net/shenxianfeng/article/details/72859830！</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一为Nginx添加ipv6模块&quot;&gt;&lt;a href=&quot;#一为Nginx添加ipv6模块&quot; class=&quot;headerlink&quot; title=&quot;一为Nginx添加ipv6模块&quot;&gt;&lt;/a&gt;一为Nginx添加ipv6模块&lt;/h1&gt;&lt;h2 id=&quot;一：检查nginx是否已经
      
    
    </summary>
    
      <category term="nginx" scheme="http://luojiamingl.github.io/categories/nginx/"/>
    
      <category term="ipv6" scheme="http://luojiamingl.github.io/categories/nginx/ipv6/"/>
    
    
      <category term="nginx" scheme="http://luojiamingl.github.io/tags/nginx/"/>
    
      <category term="ipv6" scheme="http://luojiamingl.github.io/tags/ipv6/"/>
    
  </entry>
  
  <entry>
    <title>java之并发上锁精简分析</title>
    <link href="http://luojiamingl.github.io/2018/09/14/java%E4%B9%8B%E5%B9%B6%E5%8F%91%E4%B8%8A%E9%94%81%E7%B2%BE%E7%AE%80%E5%88%86%E6%9E%90/"/>
    <id>http://luojiamingl.github.io/2018/09/14/java之并发上锁精简分析/</id>
    <published>2018-09-14T03:59:22.000Z</published>
    <updated>2018-09-14T02:52:20.794Z</updated>
    
    <content type="html"><![CDATA[<p><img src="1.png" alt="image"></p><p>“锁”在我们日常的生活工作中经常会用到，这充分保证了个人财产安全和隐私安全。</p><p>同样，在程序的世界里，也有一把锁，保证程序不会崩溃，保证我们手机钱包里的钱不会无缘无故变多变少。</p><p>这把锁（lock）作为用于保护临界区（critical section）的一种机制，被广泛应用在多线程程序中。比如 Java 应用程序出现的 synchronized 关键字，就是锁实现的一种方式。</p><p>下面我们从一个计数器的应用说起，分析下锁在 Java 程序中的应用。</p><p><strong>一个计数器</strong></p><p><img src="2.png" alt="image"></p><p>非线程安全，value++ 不是原子性操作，状态不稳定，需要同步。</p><h1 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h1><h2 id="锁定实例"><a href="#锁定实例" class="headerlink" title="锁定实例"></a>锁定实例</h2><p><img src="3.png" alt="image"></p><p>线程安全，锁的对象是当前 SafeCounter 的实例，不会影响到另一个 SafeCounter 实例的 getNext() 方法。</p><h2 id="锁定类"><a href="#锁定类" class="headerlink" title="锁定类"></a>锁定类</h2><p><img src="4.png" alt="image"></p><p>线程安全，锁的对象是 SafeCounterWithClass 类，任何实例都会受锁的影响，一般不这么用。</p><h2 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h2><p><img src="5.png" alt="image"></p><p>线程安全，锁的对象是 lock，可以灵活控制，只锁真正需要同步的代码。注意 lock 不能是 null，也不能改变。</p><h2 id="更好的-lock"><a href="#更好的-lock" class="headerlink" title="更好的 lock"></a>更好的 lock</h2><p><img src="6.png" alt="image"></p><p>线程安全，灵活控制锁竞争时的处理，拥有更好的性能。</p><h2 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h2><p><img src="7.png" alt="image"></p><p>最佳实践：使用原子操作类，不阻塞，获得最好的性能。</p><h3 id="有问题可以联系博主。"><a href="#有问题可以联系博主。" class="headerlink" title="有问题可以联系博主。"></a><strong>有问题可以联系博主</strong>。</h3><h3 id="转载请注明出处，谢谢！"><a href="#转载请注明出处，谢谢！" class="headerlink" title="转载请注明出处，谢谢！"></a><strong>转载请注明出处，谢谢</strong>！</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;1.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;“锁”在我们日常的生活工作中经常会用到，这充分保证了个人财产安全和隐私安全。&lt;/p&gt;
&lt;p&gt;同样，在程序的世界里，也有一把锁，保证程序不会崩溃，保证我们手机钱包里的钱不会无缘无故变多变少。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="java" scheme="http://luojiamingl.github.io/categories/java/"/>
    
      <category term="并发" scheme="http://luojiamingl.github.io/categories/java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://luojiamingl.github.io/tags/java/"/>
    
      <category term="并发" scheme="http://luojiamingl.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>linux下解压命令大全</title>
    <link href="http://luojiamingl.github.io/2018/07/17/linux%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B/"/>
    <id>http://luojiamingl.github.io/2018/07/17/linux压缩解压/</id>
    <published>2018-07-17T03:59:22.000Z</published>
    <updated>2018-07-18T02:05:45.867Z</updated>
    
    <content type="html"><![CDATA[<p>linux下解压命令大全</p><p>.tar </p><p>解包：tar xvf FileName.tar</p><p>打包：tar cvf FileName.tar DirName</p><p>（注：tar是打包，不是压缩！）</p><p>———————————————</p><p>.gz</p><p>解压1：gunzip FileName.gz</p><p>解压2：gzip -d FileName.gz</p><p>压缩：gzip FileName</p><p>.tar.gz 和 .tgz</p><p>解压：tar zxvf FileName.tar.gz</p><p>压缩：tar zcvf FileName.tar.gz DirName</p><p>———————————————</p><p>.bz2</p><p>解压1：bzip2 -d FileName.bz2</p><p>解压2：bunzip2 FileName.bz2</p><p>压缩： bzip2 -z FileName</p><p>.tar.bz2</p><p>解压：tar jxvf FileName.tar.bz2</p><p>压缩：tar jcvf FileName.tar.bz2 DirName</p><p>———————————————</p><p>.bz</p><p>解压1：bzip2 -d FileName.bz</p><p>解压2：bunzip2 FileName.bz</p><p>压缩：未知</p><p>.tar.bz</p><p>解压：tar jxvf FileName.tar.bz</p><p>压缩：未知<br>———————————————</p><p>.Z</p><p>解压：uncompress FileName.Z</p><p>压缩：compress FileName</p><p>.tar.Z</p><p>解压：tar Zxvf FileName.tar.Z</p><p>压缩：tar Zcvf FileName.tar.Z DirName</p><p>———————————————</p><p>.zip</p><p>解压：unzip FileName.zip</p><p>压缩：zip FileName.zip DirName</p><p>———————————————</p><p>.rar</p><p>解压：rar x FileName.rar</p><p>压缩：rar a FileName.rar DirName</p><p>———————————————</p><p>.lha</p><p>解压：lha -e FileName.lha</p><p>压缩：lha -a FileName.lha FileName</p><p>———————————————</p><p>.rpm</p><p>解包：rpm2cpio FileName.rpm | cpio -div</p><p>———————————————</p><p>.deb</p><p>解包：ar p FileName.deb data.tar.gz | tar zxf -</p><p>———————————————</p><p>.tar .tgz .tar.gz .tar.Z .tar.bz .tar.bz2 .zip .cpio .rpm .deb .slp .arj .rar .ace .lha .lzh .lzx .lzs .arc .sda .sfx .lnx .zoo .cab .kar .cpt .pit .sit .sea</p><p>解压：sEx x FileName.*</p><p>压缩：sEx a FileName.* FileName</p><p>sEx只是调用相关程序，本身并无压缩、解压功能，请注意！</p><p>gzip 命令 </p><p>减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。gzip 是在 Linux 系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。</p><p>语法：gzip [选项]</p><p>压缩（解压缩）的文件名该命令的各选项含义如下：</p><p>-c 将输出写到标准输出上，并保留原有文件。</p><p>-d 将压缩文件解压。</p><p>-l 对每个压缩文件，显示下列字段：     压缩文件的大小；未压缩文件的大小；压缩比；未压缩文件的名字</p><p>-r 递归式地查找指定目录并压缩其中的所有文件或者是解压缩。</p><p>-t 测试，检查压缩文件是否完整。</p><p>-v 对每一个压缩和解压的文件，显示文件名和压缩比。</p><p>-num 用指定的数字 num 调整压缩的速度，</p><p>-1 或 –fast 表示最快压缩方法（低压缩比），</p><p>-9 或–best表示最慢压缩方法（高压缩比）。系统缺省值为 6。指令实例：</p><p>gzip *% 把当前目录下的每个文件压缩成 .gz 文件。</p><p>gzip -dv *% 把当前目录下每个压缩的文件解压，并列出详细的信息。</p><p>gzip -l *% 详细显示例1中每个压缩的文件的信息，并不解压。</p><p>gzip usr.tar% 压缩 tar 备份文件 usr.tar，此时压缩文件的扩展名为.tar.gz。</p><h3 id="有问题可以联系博主。"><a href="#有问题可以联系博主。" class="headerlink" title="有问题可以联系博主。"></a><strong>有问题可以联系博主</strong>。</h3><h3 id="转载请注明出处，谢谢！"><a href="#转载请注明出处，谢谢！" class="headerlink" title="转载请注明出处，谢谢！"></a><strong>转载请注明出处，谢谢</strong>！</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;linux下解压命令大全&lt;/p&gt;
&lt;p&gt;.tar &lt;/p&gt;
&lt;p&gt;解包：tar xvf FileName.tar&lt;/p&gt;
&lt;p&gt;打包：tar cvf FileName.tar DirName&lt;/p&gt;
&lt;p&gt;（注：tar是打包，不是压缩！）&lt;/p&gt;
&lt;p&gt;——————————
      
    
    </summary>
    
      <category term="linux" scheme="http://luojiamingl.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://luojiamingl.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>jenkins安装配置 linux</title>
    <link href="http://luojiamingl.github.io/2018/07/06/jenkins%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>http://luojiamingl.github.io/2018/07/06/jenkins安装配置/</id>
    <published>2018-07-06T03:59:22.000Z</published>
    <updated>2018-07-06T10:06:40.662Z</updated>
    
    <content type="html"><![CDATA[<h3 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h3><p>CentOS 6.8 + java 8</p><h1 id="下载安装jenkins"><a href="#下载安装jenkins" class="headerlink" title="下载安装jenkins"></a>下载安装jenkins</h1><p><strong>方式1:</strong></p><p>yum方式安装Jenkins，最简单方便<br>yum的repos中默认是没有Jenkins的，需要先将Jenkins存储库添加到yum repos。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo</span><br><span class="line"></span><br><span class="line">sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key</span><br><span class="line"></span><br><span class="line">yum install jenkins</span><br></pre></td></tr></table></figure></p><p>如果连接超时(内网虚机可能无法链接)<br>采用</p><p><strong>方式2</strong>：</p><p>直接下载war包jenkins.war，下载地址<br><a href="https://jenkins.io/download" target="_blank" rel="noopener">https://jenkins.io/download</a></p><p>使用rpm包安装命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -ih jenkins-2.119-1.1.noarch.rpm</span><br></pre></td></tr></table></figure></p><p>自动安装完成之后： </p><p>/usr/lib/jenkins/jenkins.war    WAR包 </p><p>/etc/sysconfig/jenkins       配置文件</p><p>/var/lib/jenkins/       默认的JENKINS_HOME目录</p><p>/var/log/jenkins/jenkins.log    Jenkins日志文件</p><h1 id="启动jenkins"><a href="#启动jenkins" class="headerlink" title="启动jenkins"></a>启动jenkins</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service jenkins start</span><br></pre></td></tr></table></figure><p><a href="http://IP:8080" target="_blank" rel="noopener">http://IP:8080</a>    登录jenkins<br><img src="1.png" alt="image"></p><p>打开红色标记中的路径，取出password，填入上图，continue</p><p>可能遇到Jenkenis报错：</p><p>该jenkins实例似乎已离线</p><p><strong>解决方法：</strong></p><p>安装插件那个页面，就是提示你offline的那个页面，不要动。然后打开一个新的tab，输入网址</p><p><a href="http://ip:8080/pluginManager/advanced。" target="_blank" rel="noopener">http://ip:8080/pluginManager/advanced。</a> </p><p>这里面最底下有个【升级站点】，把其中的链接改成http的就好了，<a href="http://updates.jenkins.io/update-center.json。" target="_blank" rel="noopener">http://updates.jenkins.io/update-center.json。</a> 然后重启闭jenkins<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service jenkins restart</span><br></pre></td></tr></table></figure></p><p>这样就能正常联网了</p><p>如果还无法联网，可能是机器不能访问谷歌，因为jenkins检查网络是否连接。直接访问了谷歌</p><p>最终解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /var/lib/jenkins/updates/default.json</span><br></pre></td></tr></table></figure><p>编辑、替换：</p><p>将www.google.com替换成www.baidu.com</p><p>重启jenkins</p><p>至此  jenkins成功启动</p><h1 id="Python安装"><a href="#Python安装" class="headerlink" title="Python安装"></a>Python安装</h1><p>参照 <a href="https://www.jianshu.com/p/58d106395e45" target="_blank" rel="noopener">https://www.jianshu.com/p/58d106395e45</a></p><p>安装完成后可能出现下面问题</p><p>error while loading shared libraries: libpython3.6m.so.1.0</p><p>解决方案：</p><p>查找一下文件的位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find / -name &apos;libpython3.6m.so.1.0&apos;</span><br><span class="line">/usr/local/lib/libpython3.6m.so.1.0</span><br></pre></td></tr></table></figure></p><p>之后在目录 /etc/ld.so.conf.d 下，建立 python3.conf<br>并在 python3.conf 中加入：也就是所在的目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/lib/</span><br></pre></td></tr></table></figure></p><p>然后运行：ldconfig</p><p>再运行python3 就可以啦</p><h1 id="fabric安装"><a href="#fabric安装" class="headerlink" title="fabric安装"></a>fabric安装</h1><p>fabric有两个版本1和2，需使用1，不然会报错</p><p>安装fabric通过yum安装即可，导入epel yum库</p><p>安装fabric命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install fabric -y</span><br></pre></td></tr></table></figure></p><p>pip命令使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip show fabric</span><br></pre></td></tr></table></figure></p><p>查看fabric安装信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall fabric</span><br></pre></td></tr></table></figure></p><p>#卸载fabric</p><h1 id="maven安装"><a href="#maven安装" class="headerlink" title="maven安装"></a>maven安装</h1><h2 id="下载maven安装包"><a href="#下载maven安装包" class="headerlink" title="下载maven安装包"></a>下载maven安装包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirror.bit.edu.cn/apache/maven/maven-3/wget http://mirror.bit.edu.cn/apache/maven/maven-3/</span><br></pre></td></tr></table></figure><h2 id="解压缩maven"><a href="#解压缩maven" class="headerlink" title="解压缩maven"></a>解压缩maven</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf apache-maven-3.5.2-bin.tar.gz</span><br></pre></td></tr></table></figure><p>将maven解压缩之后的路径为：/var/local/lib</p><h2 id="配置maven环境变量"><a href="#配置maven环境变量" class="headerlink" title="配置maven环境变量"></a>配置maven环境变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br></pre></td></tr></table></figure><p>添加环境变量</p><p>export MAVEN_HOME=/var/local/apache-maven-3.5.2</p><p>export MAVEN_HOME</p><p>export PATH=$PATH:$MAVEN_HOME/bin</p><p>使配置生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></p><h1 id="jenkins插件配置"><a href="#jenkins插件配置" class="headerlink" title="jenkins插件配置"></a>jenkins插件配置</h1><p>联网状态下</p><p>系统管理–&gt;插件管理</p><p>可以直接搜索Gitlab Hook Plugin等插件自动安装</p><p>断网状态下</p><p>jenkins官网下载插件</p><p>然后高级</p><p>上传.hpi文件<br><img src="2.png" alt="image"></p><h1 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h1><p>如果虚机maven等工具安装没问题，jenkins执行脚本出现mvn:commond not found等错误，需配置jenkins环境变量</p><p>1、控制台执行 echo $PATH</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@cartoon-jenkins-dev001-whdx ~]# echo $PATH</span><br><span class="line">/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/lib/apache-maven-3.5.2/bin:/usr/local/python3.6.0/bin:/root/bin:/usr/local/lib/apache-maven-3.5.2/bin</span><br></pre></td></tr></table></figure><p>把输出的这句话复制</p><p>2、jenkins-&gt;系统管理-&gt;系统设置<br><img src="3.png" alt="image"></p><p>OK了！</p><h3 id="有问题可以联系博主。"><a href="#有问题可以联系博主。" class="headerlink" title="有问题可以联系博主。"></a><strong>有问题可以联系博主</strong>。</h3><h3 id="转载请注明出处，谢谢！"><a href="#转载请注明出处，谢谢！" class="headerlink" title="转载请注明出处，谢谢！"></a><strong>转载请注明出处，谢谢</strong>！</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;环境：&quot;&gt;&lt;a href=&quot;#环境：&quot; class=&quot;headerlink&quot; title=&quot;环境：&quot;&gt;&lt;/a&gt;环境：&lt;/h3&gt;&lt;p&gt;CentOS 6.8 + java 8&lt;/p&gt;
&lt;h1 id=&quot;下载安装jenkins&quot;&gt;&lt;a href=&quot;#下载安装jenkins
      
    
    </summary>
    
      <category term="jenkins" scheme="http://luojiamingl.github.io/categories/jenkins/"/>
    
    
      <category term="Python" scheme="http://luojiamingl.github.io/tags/Python/"/>
    
      <category term="jenkins" scheme="http://luojiamingl.github.io/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Mac-Operation not permitted</title>
    <link href="http://luojiamingl.github.io/2018/06/26/Mac-Operation%20not%20permitted/"/>
    <id>http://luojiamingl.github.io/2018/06/26/Mac-Operation not permitted/</id>
    <published>2018-06-26T10:59:22.000Z</published>
    <updated>2018-06-26T10:14:08.742Z</updated>
    
    <content type="html"><![CDATA[<p>最近在mac上操作文件发现提示</p><p>chmod: Unable to change file mode on /usr/bin/cc: Operation not permitted<br>1<br>发现是El Capitan（10.11） 加入了Rootless机制，很多系统目录不再能够随心所欲的读写了，即使设置 root 权限也不行。</p><p>以下路径无法写和执行</p><p>/System<br>/bin<br>/sbin<br>/usr (except /usr/local)<br>1<br>2<br>3<br>4<br>加入这个机制主要是为了防止恶意程序的入侵，更多我们可以查看官网</p><p><a href="https://developer.apple.com/videos/play/wwdc2015/706/" target="_blank" rel="noopener">https://developer.apple.com/videos/play/wwdc2015/706/</a></p><p>如何关闭<br>重启按住 Command+R，进入恢复模式，打开Terminal<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csrutil disable</span><br></pre></td></tr></table></figure></p><p>如何开启<br>重启按住 Command+R，进入恢复模式，打开Terminal。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csrutil enable</span><br></pre></td></tr></table></figure></p><h3 id="有问题可以联系博主。"><a href="#有问题可以联系博主。" class="headerlink" title="有问题可以联系博主。"></a><strong>有问题可以联系博主</strong>。</h3><h3 id="转载请注明出处，谢谢！"><a href="#转载请注明出处，谢谢！" class="headerlink" title="转载请注明出处，谢谢！"></a><strong>转载请注明出处，谢谢</strong>！</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在mac上操作文件发现提示&lt;/p&gt;
&lt;p&gt;chmod: Unable to change file mode on /usr/bin/cc: Operation not permitted&lt;br&gt;1&lt;br&gt;发现是El Capitan（10.11） 加入了Rootless
      
    
    </summary>
    
      <category term="Shell" scheme="http://luojiamingl.github.io/categories/Shell/"/>
    
    
      <category term="Shell" scheme="http://luojiamingl.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Python远程部署命令Fabric</title>
    <link href="http://luojiamingl.github.io/2018/04/22/Python%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2%E5%91%BD%E4%BB%A4Fabric/"/>
    <id>http://luojiamingl.github.io/2018/04/22/Python远程部署命令Fabric/</id>
    <published>2018-04-22T03:59:22.000Z</published>
    <updated>2018-04-12T02:23:46.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python远程部署利器Fabric详解"><a href="#Python远程部署利器Fabric详解" class="headerlink" title="Python远程部署利器Fabric详解"></a>Python远程部署利器Fabric详解</h1><p>Fabric是一个Python的库，它提供了丰富的同SSH交互的接口，可以用来在本地或远程机器上自动化、流水化地执行Shell命令。因此它非常适合用来做应用的远程部署及系统维护。其上手也极其简单，你需要的只是懂得基本的Shell命令。</p><p>本文将为大家详细介绍Fabric的使用。</p><h1 id="安装Fabric"><a href="#安装Fabric" class="headerlink" title="安装Fabric"></a>安装Fabric</h1><p>首先Python的版本必须是2.7以上，可以通过下面的命令查看当前Python的版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -V</span><br></pre></td></tr></table></figure></p><p>Fabric的官网是<a href="https://note.youdao.com/" target="_blank" rel="noopener">www.fabfile.org</a>，源码托管在Github上。你可以clone源码到本地，然后通过下面的命令来安装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python setup.py develop</span><br></pre></td></tr></table></figure></p><p>在执行源码安装前，你必须先将Fabric的依赖包Paramiko装上。所以，个人还是推荐使用pip安装，只需一条命令即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install fabric</span><br></pre></td></tr></table></figure></p><p>第一个例子</p><p>万事从Hello World开始</p><p>我们创建一个fabfile.py文件，然后写个hello函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def hello():</span><br><span class="line">    print &quot;Hello Fabric!&quot;</span><br></pre></td></tr></table></figure></p><p>现在，让我们在fabfile.py的目录下执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ fab hello</span><br></pre></td></tr></table></figure></p><p>你可以在终端看到”Hello Fabric!”字样。</p><p>简单解释下，fabfile.py文件中每个函数就是一个任务，任务名即函数名，上例中是hello。fab命令就是用来执行fabfile.py中定义的任务，它必须显式地指定任务名。你可以使用参数-l来列出当前fabfile.py文件中定义了哪些任务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ fab -l</span><br></pre></td></tr></table></figure></p><p>任务可以带参数，比如我们将hello函数改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def hello(name, value):</span><br><span class="line">    print &quot;Hello Fabric! %s=%s&quot; % (name,value)</span><br></pre></td></tr></table></figure><p>此时执行hello任务时，就要传入参数值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ fab hello:name=Year,value=2016</span><br></pre></td></tr></table></figure></p><p>Fabric的脚本建议写在fabfile.py文件中，如果你想换文件名，那就要在”fab”命令中用”-f”指定。比如我们将脚本放在script.py中，就要执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ fab -f script.py hello</span><br></pre></td></tr></table></figure></p><h4 id="执行本地命令"><a href="#执行本地命令" class="headerlink" title="执行本地命令"></a>执行本地命令</h4><p>“fabric.api”包里的”local()”方法可以用来执行本地Shell命令，比如让我们列出本地”/home/bjhee”目录下的所有文件及目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from fabric.api import local</span><br><span class="line"> </span><br><span class="line">def hello():</span><br><span class="line">    local(&apos;ls -l /home/bjhee/&apos;)</span><br></pre></td></tr></table></figure><p>“local()”方法有一个”capture”参数用来捕获标准输出，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def hello():</span><br><span class="line">    output = local(&apos;echo Hello&apos;, capture=True)</span><br></pre></td></tr></table></figure><p>这样，Hello字样不会输出到屏幕上，而是保存在变量output里。”capture”参数的默认值是False。</p><h1 id="执行远程命令"><a href="#执行远程命令" class="headerlink" title="执行远程命令"></a>执行远程命令</h1><p>Fabric真正强大之处不是在执行本地命令，而是可以方便的执行远程机器上的Shell命令。它通过SSH实现，你需要的是在脚本中配置远程机器地址及登录信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from fabric.api import run, env</span><br><span class="line"> </span><br><span class="line">env.hosts = [&apos;example1.com&apos;, &apos;example2.com&apos;]</span><br><span class="line">env.user = &apos;bjhee&apos;</span><br><span class="line">env.password = &apos;111111&apos;</span><br><span class="line"> </span><br><span class="line">def hello():</span><br><span class="line">    run(&apos;ls -l /home/bjhee/&apos;)</span><br><span class="line">```    </span><br><span class="line">“fabric.api”包里的”run()”方法可以用来执行远程Shell命令。上面的任务会分别到两台服务器example1.com和example2.com上执行”ls -l /home/bjhee/”命令。这里假设两台服务器的用户名都是”bjhee”，密码都是6个1。你也可以把用户直接写在hosts里，比如：</span><br></pre></td></tr></table></figure><p>env.hosts = [‘bjhee@example1.com’, ‘bjhee@example2.com’]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果你的”env.hosts”里没有配置某个服务器，但是你又想在这个服务器上执行任务，你可以在命令行中通过”-H”指定远程服务器地址，多个服务器地址用逗号分隔：</span><br></pre></td></tr></table></figure></p><p>$ fab -H bjhee@example3.com,bjhee@example4.com hello<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">另外，多台机器的任务是串行执行的，关于并行任务的执行我们在之后会介绍。</span><br><span class="line"></span><br><span class="line">如果对于不同的服务器，我们想执行不同的任务，上面的方法似乎做不到，那怎么办？我们要对服务器定义角色：</span><br></pre></td></tr></table></figure></p><p>from fabric.api import env, roles, run, execute, cd</p><p>env.roledefs = {<br>    ‘staging’: [‘bjhee@example1.com’,’bjhee@example2.com’],<br>    ‘build’: [‘build@example3.com’]<br>}</p><p>env.passwords = {<br>    ‘staging’: ‘11111’,<br>    ‘build’: ‘123456’<br>}</p><p>@roles(‘build’)<br>def build():<br>    with cd(‘/home/build/myapp/‘):<br>        run(‘git pull’)<br>        run(‘python setup.py’)</p><p>@roles(‘staging’)<br>def deploy():<br>    run(‘tar xfz /tmp/myapp.tar.gz’)<br>    run(‘cp /tmp/myapp /home/bjhee/www/‘)</p><p>def task():<br>    execute(build)<br>    execute(deploy)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">现在让我们执行：</span><br></pre></td></tr></table></figure></p><p>$ fab task<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这时Fabric会先在一台build服务器上执行build任务，然后在两台staging服务器上分别执行deploy任务。”@roles”装饰器指定了它所装饰的任务会被哪个角色的服务器执行。</span><br><span class="line"></span><br><span class="line">如果某一任务上没有指定某个角色，但是你又想让这个角色的服务器也能运行该任务，你可以通过”-R”来指定角色名，多个角色用逗号分隔：</span><br></pre></td></tr></table></figure></p><p>$ fab -R build deploy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">这样”build”和”staging”角色的服务器都会运行”deploy”任务了。</span><br><span class="line"></span><br><span class="line">**注**：”staging”是装饰器默认的，因此不用通过”-R”指定。</span><br><span class="line"></span><br><span class="line">此外，上面的例子中，服务器的登录密码都是明文写在脚本里的。这样做不安全，推荐的方式是设置SSH自动登录，具体方法大家可以去网上搜搜。</span><br><span class="line"></span><br><span class="line"># SSH功能函数</span><br><span class="line"></span><br><span class="line">到目前为止，我们介绍了”local()”和”run()”函数分别用来执行本地和远程Shell命令。Fabric还提供了其他丰富的功能函数来辅助执行命令，这里我们介绍几个常用的：</span><br><span class="line"></span><br><span class="line">## sudo: </span><br><span class="line">以超级用户权限执行远程命令</span><br><span class="line">功能类似于”run()”方法，区别是它相当于在Shell命令前加上了”sudo”，所以拥有超级用户的权限。使用此功能前，你需要将你的用户设为sudoer，而且无需输密码。具体操作可参见我的这篇文章。</span><br></pre></td></tr></table></figure></p><p>from fabric.api import env, sudo</p><p>env.hosts = [‘bjhee@example1.com’, ‘bjhee@example2.com’]<br>env.password = ‘111111’</p><p>def hello():<br>    sudo(‘mkdir /var/www/myapp’)<br>get(remote, local):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从远程机器上下载文件到本地</span><br><span class="line">它的工作原理是基于scp命令，使用的方法如下：</span><br></pre></td></tr></table></figure></p><p>from fabric.api import env, get</p><p>env.hosts = [‘bjhee@example.com’,]<br>env.password = ‘111111’</p><p>def hello():<br>    get(‘/var/log/myapp.log’, ‘myapp-0301.log’)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">上述任务将远程机上”/var/log/myapp.log”文件下载到本地当前目录，并命名为”myapp-0301.log”。</span><br><span class="line"></span><br><span class="line">## put(local, remote):</span><br><span class="line"></span><br><span class="line">从本地上传文件到远程机器上</span><br><span class="line">同get一样，put方法也是基于scp命令，使用的方法如下：</span><br></pre></td></tr></table></figure></p><p>from fabric.api import env, put</p><p>env.hosts = [‘bjhee@example1.com’, ‘bjhee@example2.com’]<br>env.password = ‘111111’</p><p>def hello():<br>    put(‘/tmp/myapp-0301.tar.gz’, ‘/var/www/myapp.tar.gz’)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上述任务将本地”/tmp/myapp-0301.tar.gz”文件分别上传到两台远程机的”/var/www/”目录下，并命名为”myapp.tar.gz”。如果远程机上的目录需要超级用户权限才能放文件，可以在”put()”方法里加上”use_sudo”参数：</span><br></pre></td></tr></table></figure></p><pre><code>put(&apos;/tmp/myapp-0301.tar.gz&apos;, &apos;/var/www/myapp.tar.gz&apos;, use_sudo=True)</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## prompt: 提示输入</span><br><span class="line">该方法类似于Shell中的”read”命令，它会在终端显示一段文字来提示用户输入，并将用户的输入保存在变量里：</span><br></pre></td></tr></table></figure><p>from fabric.api import env, get, prompt</p><p>env.hosts = [‘bjhee@example.com’,]<br>env.password = ‘111111’</p><p>def hello():<br>    filename = prompt(‘Please input file name: ‘)<br>    get(‘/var/log/myapp.log’, ‘%s.log’ % filename)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">现在下载后的文件名将由用户的输入来决定。我们还可以对用户输入给出默认值及类型检查：</span><br></pre></td></tr></table></figure></p><p>port = prompt(‘Please input port number: ‘, default=8080, validate=int)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行任务后，终端会显示：</span><br></pre></td></tr></table></figure></p><p>Please input port number: [8080]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果你直接按回车，则port变量即为默认值8080；如果你输入字符串，终端会提醒你类型验证失败，让你重新输入，直到正确为止。</span><br><span class="line"></span><br><span class="line">## reboot: 重启服务器</span><br><span class="line">看方法名就猜到了，有时候安装好环境后，需要重启服务器，这时就要用到”reboot()”方法，你可以用”wait”参数来控制其等待多少秒后重启，没有此参数则代表立即重启：</span><br></pre></td></tr></table></figure></p><p>from fabric.api import env, reboot</p><p>env.hosts = [‘bjhee@example.com’,]<br>env.password = ‘111111’</p><p>def restart():<br>    reboot(wait=60)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">上面的restart任务将在一分钟后重启服务器。</span><br><span class="line"></span><br><span class="line">## 上下文管理器</span><br><span class="line">Fabric的上下文管理器是一系列与Python的”with”语句配合使用的方法，它可以在”with”语句块内设置当前工作环境的上下文。让我们介绍几个常用的：</span><br><span class="line"></span><br><span class="line">cd: 设置远程机器的当前工作目录</span><br><span class="line">“cd()”方法在之前的范例中出现过，”with cd()”语句块可以用来设置远程机的工作目录：</span><br></pre></td></tr></table></figure></p><p>from fabric.api import env, cd, put</p><p>env.hosts = [‘bjhee@example1.com’, ]<br>env.password = ‘111111’</p><p>def hello():<br>    with cd(‘/var/www/‘):<br>        put(‘/tmp/myapp-0301.tar.gz’, ‘myapp.tar.gz’)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">上例中的文件会上传到远程机的”/var/www/”目录下。出了”with cd()”语句块后，工作目录就回到初始的状态，也就是”bjhee”用户的根目录。</span><br><span class="line"></span><br><span class="line">## lcd: 设置本地工作目录</span><br><span class="line">“lcd()”就是”local cd”的意思，用法同”cd()”一样，区别是它设置的是本地的工作目录：</span><br></pre></td></tr></table></figure></p><p>from fabric.api import env, cd, lcd, put</p><p>env.hosts = [‘bjhee@example1.com’, ]<br>env.password = ‘111111’</p><p>def hello():<br>    with cd(‘/var/www/‘):<br>        with lcd(‘/tmp/‘):<br>            put(‘myapp-0301.tar.gz’, ‘myapp.tar.gz’)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个例子的执行效果跟上个例子一样。</span><br><span class="line"></span><br><span class="line">## path: 添加远程机的PATH路径</span><br></pre></td></tr></table></figure></p><p>from fabric.api import env, run, path</p><p>env.hosts = [‘bjhee@example1.com’, ]<br>env.password = ‘111111’</p><p>def hello():<br>    with path(‘/home/bjhee/tmp’):<br>        run(‘echo $PATH’)<br>    run(‘echo $PATH’)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">假设我们的PATH环境变量默认是”/sbin:/bin”，在上述”with path()”语句块内PATH变量将变为”/sbin:/bin:/home/bjhee/tmp”。出了with语句块后，PATH又回到原来的值。</span><br><span class="line"></span><br><span class="line">## settings: 设置Fabric环境变量参数</span><br><span class="line">Fabric环境变量即是我们例子中一直出现的”fabric.api.env”，它支持的参数可以从官方文档中查到。</span><br></pre></td></tr></table></figure></p><p>from fabric.api import env, run, settings</p><p>env.hosts = [‘bjhee@example1.com’, ]<br>env.password = ‘111111’</p><p>def hello():<br>    with settings(warn_only=True):<br>        run(‘echo $USER’)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我们将环境参数”warn_only”暂时设为True，这样遇到错误时任务不会退出。</span><br><span class="line"></span><br><span class="line">## shell_env: 设置Shell环境变量</span><br><span class="line">可以用来临时设置远程和本地机上Shell的环境变量。</span><br></pre></td></tr></table></figure></p><p>from fabric.api import env, run, local, shell_env</p><p>env.hosts = [‘bjhee@example1.com’, ]<br>env.password = ‘111111’</p><p>def hello():<br>    with shell_env(JAVA_HOME=’/opt/java’):<br>        run(‘echo $JAVA_HOME’)<br>        local(‘echo $JAVA_HOME’)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## prefix: 设置命令执行前缀</span><br></pre></td></tr></table></figure></p><p>from fabric.api import env, run, local, prefix</p><p>env.hosts = [‘bjhee@example1.com’, ]<br>env.password = ‘111111’</p><p>def hello():<br>    with prefix(‘echo Hi’):<br>        run(‘pwd’)<br>        local(‘pwd’)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在上述”with prefix()”语句块内，所有的”run()”或”local()”方法的执行都会加上”echo Hi &amp;&amp; “前缀，也就是效果等同于：</span><br></pre></td></tr></table></figure></p><p>run(‘echo Hi &amp;&amp; pwd’)<br>local(‘echo Hi &amp;&amp; pwd’)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">配合后一节我们会讲到的错误处理，它可以确保在”prefix()”方法上的命令执行成功后才会执行语句块内的命令。</span><br><span class="line"></span><br><span class="line"># 错误处理</span><br><span class="line">默认情况下，Fabric在任务遇到错误时就会退出，如果我们希望捕获这个错误而不是退出任务的话，就要开启”warn_only”参数。在上面介绍”settings()”上下文管理器时，我们已经看到了临时开启”warn_only”的方法了，如果要全局开启，有两个办法：</span><br><span class="line"></span><br><span class="line">在执行”fab”命令时加上”-w”参数</span><br></pre></td></tr></table></figure></p><p>$ fab -w hello<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设置”env.warn_only”环境参数为True</span><br></pre></td></tr></table></figure></p><p>from fabric.api import env</p><p>env.warn_only = True<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">现在遇到错误时，控制台会打出一个警告信息，然后继续执行后续任务。那我们怎么捕获错误并处理呢？像”run()”, “local()”, “sudo()”, “get()”, “put()”等SSH功能函数都有返回值。当返回值的”succeeded”属性为True时，说明执行成功，反之就是失败。你也可以检查返回值的”failed”属性，为True时就表示执行失败，有错误发生。在开启”warn_only”后，你可以通过”failed”属性检查捕获错误，并执行相应的操作。</span><br></pre></td></tr></table></figure></p><p>from fabric.api import env, cd, put</p><p>env.hosts = [‘bjhee@example1.com’, ]<br>env.password = ‘111111’</p><p>def hello():<br>    with cd(‘/var/www/‘):<br>        upload = put(‘/tmp/myapp-0301.tar.gz’, ‘myapp.tar.gz’)<br>        if upload.failed:<br>            sudo(‘rm myapp.tar.gz’)<br>            put(‘/tmp/myapp-0301.tar.gz’, ‘myapp.tar.gz’, use_sudo=True)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 并行执行</span><br><span class="line">我们在介绍执行远程命令时曾提到过多台机器的任务默认情况下是串行执行的。Fabric支持并行任务，当服务器的任务之间没有依赖时，并行可以有效的加快执行速度。怎么开启并行执行呢？办法也是两个：</span><br><span class="line"></span><br><span class="line">在执行”fab”命令时加上”-P”参数</span><br></pre></td></tr></table></figure></p><p>$ fab -P hello<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设置”env.parallel”环境参数为True</span><br></pre></td></tr></table></figure></p><p>from fabric.api import env</p><p>env.parallel = True<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果，我们只想对某一任务做并行的话，我们可以在任务函数上加上”@parallel”装饰器：</span><br></pre></td></tr></table></figure></p><p>from fabric.api import parallel</p><p>@parallel<br>def runs_in_parallel():<br>    pass</p><p>def runs_serially():<br>    pass<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这样即便并行未开启，”runs_in_parallel()”任务也会并行执行。反过来，我们可以在任务函数上加上”@serial”装饰器：</span><br></pre></td></tr></table></figure></p><p>from fabric.api import serial</p><p>def runs_in_parallel():<br>    pass</p><p>@serial<br>def runs_serially():<br>    pass<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这样即便并行已经开启，”runs_serially()”任务也会串行执行。</span><br><span class="line"></span><br><span class="line">**补充**：</span><br><span class="line">这个部分用来补充Fabric的一些特别功能：</span><br><span class="line"></span><br><span class="line">终端输出带颜色</span><br><span class="line">我们习惯上认为绿色表示成功，黄色表示警告，而红色表示错误，Fabric支持带这些颜色的输出来提示相应类型的信息：</span><br></pre></td></tr></table></figure></p><p>from fabric.colors import *</p><p>def hello():<br>    print green(“Successful”)<br>    print yellow(“Warning”)<br>    print red(“Error”)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 限制任务只能被执行一次</span><br><span class="line">通过”execute()”方法，可以在一个”fab”命令中多次调用同一任务，如果想避免这个发生，就要在任务函数上加上”@runs_once”装饰器。</span><br></pre></td></tr></table></figure></p><p>from fabric.api import execute, runs_once</p><p>@runs_once<br>def hello():<br>    print “Hello Fabric!”</p><p>def test():<br>    execute(hello)<br>    execute(hello)<br>```<br>现在不管我们”execute”多少次hello任务，都只会输出一次”Hello Fabric!”字样</p><p>参考资料：<a href="http://www.bjhee.com/fabric.html" target="_blank" rel="noopener">http://www.bjhee.com/fabric.html</a></p><h3 id="有问题可以联系博主。"><a href="#有问题可以联系博主。" class="headerlink" title="有问题可以联系博主。"></a><strong>有问题可以联系博主</strong>。</h3><h3 id="转载请注明出处，谢谢！"><a href="#转载请注明出处，谢谢！" class="headerlink" title="转载请注明出处，谢谢！"></a><strong>转载请注明出处，谢谢</strong>！</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python远程部署利器Fabric详解&quot;&gt;&lt;a href=&quot;#Python远程部署利器Fabric详解&quot; class=&quot;headerlink&quot; title=&quot;Python远程部署利器Fabric详解&quot;&gt;&lt;/a&gt;Python远程部署利器Fabric详解&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="Python" scheme="http://luojiamingl.github.io/categories/Python/"/>
    
    
      <category term="Shell" scheme="http://luojiamingl.github.io/tags/Shell/"/>
    
      <category term="Python" scheme="http://luojiamingl.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>redis集群分析</title>
    <link href="http://luojiamingl.github.io/2018/04/11/redis%E9%9B%86%E7%BE%A4/"/>
    <id>http://luojiamingl.github.io/2018/04/11/redis集群/</id>
    <published>2018-04-11T11:59:22.000Z</published>
    <updated>2018-04-11T11:03:33.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么用集群？"><a href="#为什么用集群？" class="headerlink" title="为什么用集群？"></a>为什么用集群？</h1><p>通常，为了提高网站响应速度，总是把热点数据保存在内存中而不是直接从后端数据库中读取。Redis是一个很好的Cache工具。大型网站应用，热点数据量往往巨大，几十G上百G是很正常的事儿，在这种情况下，如何正确架构Redis呢？</p><p>首先，无论我们是使用自己的物理主机，还是使用云服务主机，内存资源往往是有限制的，scaleup不是一个好办法，我们需要scaleout横向可伸缩扩展，这需要由多台主机协同提供服务，即分布式多个Redis实例协同运行。</p><p>其次，目前硬件资源成本降低，多核CPU，几十G内存的主机很普遍，对于主进程是单线程工作的Redis，只运行一个实例就显得有些浪费。同时，管理一个巨大内存不如管理相对较小的内存高效。因此，实际使用中，通常一台机器上同时跑多个Redis实例。</p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h3 id="1-Redis官方集群方案-Redis-Cluster"><a href="#1-Redis官方集群方案-Redis-Cluster" class="headerlink" title="1.Redis官方集群方案 Redis Cluster"></a>1.Redis官方集群方案 Redis Cluster</h3><p>Redis Cluster是一种服务器Sharding技术，3.0版本开始正式提供。</p><p>Redis Cluster中，Sharding采用slot(槽)的概念，一共分成16384个槽，这有点儿类pre sharding思路。对于每个进入Redis的键值对，根据key进行散列，分配到这16384个slot中的某一个中。使用的hash算法也比较简单，就是CRC16后16384取模。</p><p>Redis集群中的每个node(节点)负责分摊这16384个slot中的一部分，也就是说，每个slot都对应一个node负责处理。当动态添加或减少node节点时，需要将16384个槽做个再分配，槽中的键值也要迁移。当然，这一过程，在目前实现中，还处于半自动状态，需要人工介入。</p><p>Redis集群，要保证16384个槽对应的node都正常工作，如果某个node发生故障，那它负责的slots也就失效，整个集群将不能工作。</p><p>为了增加集群的可访问性，官方推荐的方案是将node配置成主从结构，即一个master主节点，挂n个slave从节点。这时，如果主节点失效，Redis Cluster会根据选举算法从slave节点中选择一个上升为主节点，整个集群继续对外提供服务。这非常类似前篇文章提到的Redis Sharding场景下服务器节点通过Sentinel监控架构成主从结构，只是Redis Cluster本身提供了故障转移容错的能力。</p><p>Redis Cluster的新节点识别能力、故障判断及故障转移能力是通过集群中的每个node都在和其它nodes进行通信，这被称为集群总线(cluster bus)。它们使用特殊的端口号，即对外服务端口号加10000。例如如果某个node的端口号是6379，那么它与其它nodes通信的端口号是16379。nodes之间的通信采用特殊的二进制协议。</p><p>对客户端来说，整个cluster被看做是一个整体，客户端可以连接任意一个node进行操作，就像操作单一Redis实例一样，当客户端操作的key没有分配到该node上时，Redis会返回转向指令，指向正确的node，这有点儿像浏览器页面的302 redirect跳转。</p><p>Redis Cluster是Redis 3.0以后才正式推出，时间较晚，目前能证明在大规模生产环境下成功的案例还不是很多，需要时间检验。</p><h3 id="2-Redis-Sharding集群"><a href="#2-Redis-Sharding集群" class="headerlink" title="2.Redis Sharding集群"></a>2.Redis Sharding集群</h3><p>Redis 3正式推出了官方集群技术，解决了多Redis实例协同服务问题。Redis Cluster可以说是服务端Sharding分片技术的体现，即将键值按照一定算法合理分配到各个实例分片上，同时各个实例节点协调沟通，共同对外承担一致服务。</p><p>多Redis实例服务，比单Redis实例要复杂的多，这涉及到定位、协同、容错、扩容等技术难题。这里，我们介绍一种轻量级的客户端Redis Sharding技术。</p><p>Redis Sharding可以说是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法。其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。这样，客户端就知道该向哪个Redis节点操作数据。Sharding架构如图：</p><p><img src="1.jpg" alt="image"></p><p>庆幸的是，java redis客户端驱动jedis，已支持Redis Sharding功能，即ShardedJedis以及结合缓存池的ShardedJedisPool。</p><p>Jedis的Redis Sharding实现具有如下特点：</p><p><strong>1</strong>.采用一致性哈希算法(consistent hashing)，将key和节点name同时hashing，然后进行映射匹配，采用的算法是MURMUR_HASH。采用一致性哈希而不是采用简单类似哈希求模映射的主要原因是当增加或减少节点时，不会产生由于重新匹配造成的rehashing。一致性哈希只影响相邻节点key分配，影响量小。</p><p><strong>2</strong>.为了避免一致性哈希只影响相邻节点造成节点分配压力，ShardedJedis会对每个Redis节点根据名字(没有，Jedis会赋予缺省名字)会虚拟化出160个虚拟节点进行散列。根据权重weight，也可虚拟化出160倍数的虚拟节点。用虚拟节点做映射匹配，可以在增加或减少Redis节点时，key在各Redis节点移动再分配更均匀，而不是只有相邻节点受影响。</p><p><strong>3</strong>.ShardedJedis支持keyTagPattern模式，即抽取key的一部分keyTag做sharding，这样通过合理命名key，可以将一组相关联的key放入同一个Redis节点，这在避免跨节点访问相关数据时很重要。</p><h1 id="扩容问题"><a href="#扩容问题" class="headerlink" title="扩容问题"></a>扩容问题</h1><p>Redis Sharding采用客户端Sharding方式，服务端Redis还是一个个相对独立的Redis实例节点，没有做任何变动。同时，我们也不需要增加额外的中间处理组件，这是一种非常轻量、灵活的Redis多实例集群方法。</p><p>当然，Redis Sharding这种轻量灵活方式必然在集群其它能力方面做出妥协。比如扩容，当想要增加Redis节点时，尽管采用一致性哈希，毕竟还是会有key匹配不到而丢失，这时需要键值迁移。</p><p>作为轻量级客户端sharding，处理Redis键值迁移是不现实的，这就要求应用层面允许Redis中数据丢失或从后端数据库重新加载数据。但有些时候，击穿缓存层，直接访问数据库层，会对系统访问造成很大压力。有没有其它手段改善这种情况？</p><p>Redis作者给出了一个比较讨巧的办法–presharding，即预先根据系统规模尽量部署好多个Redis实例，这些实例占用系统资源很小，一台物理机可部署多个，让他们都参与sharding，当需要扩容时，选中一个实例作为主节点，新加入的Redis节点作为从节点进行数据复制。数据同步后，修改sharding配置，让指向原实例的Shard指向新机器上扩容后的Redis节点，同时调整新Redis节点为主节点，原实例可不再使用。</p><p>presharding是预先分配好足够的分片，扩容时只是将属于某一分片的原Redis实例替换成新的容量更大的Redis实例。参与sharding的分片没有改变，所以也就不存在key值从一个区转移到另一个分片区的现象，只是将属于同分片区的键值从原Redis实例同步到新Redis实例。</p><p>并不是只有增删Redis节点引起键值丢失问题，更大的障碍来自Redis节点突然宕机。在《Redis持久化》一文中已提到，为不影响Redis性能，尽量不开启AOF和RDB文件保存功能，可架构Redis主备模式，主Redis宕机，数据不会丢失，备Redis留有备份。</p><p>这样，我们的架构模式变成一个Redis节点切片包含一个主Redis和一个备Redis。在主Redis宕机时，备Redis接管过来，上升为主Redis，继续提供服务。主备共同组成一个Redis节点，通过自动故障转移，保证了节点的高可用性。则Sharding架构演变成：</p><p>Redis Sentinel提供了主备模式下Redis监控、故障转移功能达到系统的高可用性。</p><p>高访问量下，即使采用Sharding分片，一个单独节点还是承担了很大的访问压力，这时我们还需要进一步分解。通常情况下，应用访问Redis读操作量和写操作量差异很大，读常常是写的数倍，这时我们可以将读写分离，而且读提供更多的实例数。</p><p>可以利用主从模式实现读写分离，主负责写，从负责只读，同时一主挂多个从。在Sentinel监控下，还可以保障节点故障的自动监测。</p><h2 id="3-利用代理中间件实现大规模Redis集群"><a href="#3-利用代理中间件实现大规模Redis集群" class="headerlink" title="3.利用代理中间件实现大规模Redis集群"></a>3.利用代理中间件实现大规模Redis集群</h2><p>上面分别介绍了多Redis服务器集群的两种方式，它们是基于客户端sharding的Redis Sharding和基于服务端sharding的Redis Cluster。</p><p>客户端sharding技术其优势在于服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强。其不足之处在于：</p><p>1.由于sharding处理放到客户端，规模进步扩大时给运维带来挑战。</p><p>2.服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整。</p><p>3.连接不能共享，当应用规模增大时，资源浪费制约优化。</p><p>服务端sharding的Redis Cluster其优势在于服务端Redis集群拓扑结构变化时，客户端不需要感知，客户端像使用单Redis服务器一样使用Redis集群，运维管理也比较方便。</p><p>不过Redis Cluster正式版推出时间不长，系统稳定性、性能等都需要时间检验，尤其在大规模使用场合。</p><p>能不能结合二者优势？即能使服务端各实例彼此独立，支持线性可伸缩，同时sharding又能集中处理，方便统一管理？本篇介绍的Redis代理中间件twemproxy就是这样一种利用中间件做sharding的技术。</p><p>twemproxy处于客户端和服务器的中间，将客户端发来的请求，进行一定的处理后(如sharding)，再转发给后端真正的Redis服务器。也就是说，客户端不直接访问Redis服务器，而是通过twemproxy代理中间件间接访问。</p><p>参照Redis Sharding架构，增加代理中间件的Redis集群架构如下：</p><p>twemproxy中间件的内部处理是无状态的，它本身可以很轻松地集群，这样可避免单点压力或故障。</p><p>twemproxy又叫nutcracker，起源于twitter系统中redis/memcached集群开发实践，twemproxy后端不仅支持redis，同时也支持memcached，这是twitter系统具体环境造成的。</p><p>由于使用了中间件，twemproxy可以通过共享与后端系统的连接，降低客户端直接连接后端服务器的连接数量。同时，它也提供sharding功能，支持后端服务器集群水平扩展。统一运维管理也带来了方便。</p><p>当然，也是由于使用了中间件代理，相比客户端直连服务器方式，性能上会有所损耗，实测结果大约降低了20%左右。</p><h3 id="有问题可以联系博主。"><a href="#有问题可以联系博主。" class="headerlink" title="有问题可以联系博主。"></a><strong>有问题可以联系博主</strong>。</h3><h3 id="转载请注明出处，谢谢！"><a href="#转载请注明出处，谢谢！" class="headerlink" title="转载请注明出处，谢谢！"></a><strong>转载请注明出处，谢谢</strong>！</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么用集群？&quot;&gt;&lt;a href=&quot;#为什么用集群？&quot; class=&quot;headerlink&quot; title=&quot;为什么用集群？&quot;&gt;&lt;/a&gt;为什么用集群？&lt;/h1&gt;&lt;p&gt;通常，为了提高网站响应速度，总是把热点数据保存在内存中而不是直接从后端数据库中读取。Redis是一个
      
    
    </summary>
    
      <category term="redis" scheme="http://luojiamingl.github.io/categories/redis/"/>
    
    
      <category term="redis" scheme="http://luojiamingl.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>判断一个单链表是否有环</title>
    <link href="http://luojiamingl.github.io/2018/03/26/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/"/>
    <id>http://luojiamingl.github.io/2018/03/26/判断一个单链表是否有环/</id>
    <published>2018-03-26T11:59:22.000Z</published>
    <updated>2018-04-11T11:03:33.663Z</updated>
    
    <content type="html"><![CDATA[<p>三类情况：<br>（1）<img src="1.png" alt="image"><br>（2）<img src="2.png" alt="image"><br>（3）<img src="3.png" alt="image"><br>1、遇到这个问题，首先想到的是遍历链表，寻找是否有相同地址，借此判断链表中是否有环。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">listnode_ptr current =head-&gt;next;</span><br><span class="line">while(current)</span><br><span class="line">&#123;</span><br><span class="line">  if(current==head)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;有环！\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    current=current-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;无环！\n&quot;);</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure></p><p>这段代码满足了（1）（链表无环）、（2）（链表头尾相连)两类情况，却没有将（3）情况考虑在内，如果出现（3）类情况，程序会进入死循环。</p><p>2、将（3）考虑在内，首先想到我们可能需要一块空间来存储指针，遍历新指针时将其和储存的旧指针比对，若有相同指针，则该链表有环，否则将这个新指针存下来后继续往下读取，直到遇见NULL，这说明这个链表无环。</p><p>上述方法虽然可行，可是否还有更简便的算法？</p><p>3、假设有两个学生A和B在跑道上跑步，两人从相同起点出发，假设A的速度为2m/s，B的速度为1m/s,结果会发生什么？</p><p>答案很简单，A绕了跑道一圈之后会追上B！</p><p>将这个问题延伸到链表中，跑道就是链表，我们可以设置两个指针，a跑的快，b跑的慢，如果链表有环，那么当程序执行到某一状态时，a==b。如果链表没有环，程序会执行到a==NULL，结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">listnode_ptr fast=head-&gt;next; </span><br><span class="line">listnode_ptr slow=head;</span><br><span class="line">while(fast)</span><br><span class="line">&#123;</span><br><span class="line">    if(fast==slow)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;环！\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        fast=fast-&gt;next;</span><br><span class="line">        if(!fast)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;无环！\n&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;无环！\n&quot;); </span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure><p>4、关于算法复杂度：</p><p><img src="4.png" alt="image"></p><p>如图，链表长度为n，环节点个数为m，则循环 t=n-m 次时，slow进入环中，此时，我们假设fast与slow相距x个节点，那么，经过t’次循环，二者相遇时，有：<br>2t’=t’+（m-x） -&gt; t’=m-x -&gt; t’&lt;=m.<br>因此，总共循环了T=t+t’ &lt;= n. 算法复杂度为O(n).</p><h3 id="有问题可以联系博主。"><a href="#有问题可以联系博主。" class="headerlink" title="有问题可以联系博主。"></a><strong>有问题可以联系博主</strong>。</h3><h3 id="转载请注明出处，谢谢！"><a href="#转载请注明出处，谢谢！" class="headerlink" title="转载请注明出处，谢谢！"></a><strong>转载请注明出处，谢谢</strong>！</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;三类情况：&lt;br&gt;（1）&lt;img src=&quot;1.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;（2）&lt;img src=&quot;2.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;（3）&lt;img src=&quot;3.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;1、遇到这个问题，首先想到的是遍历链表，
      
    
    </summary>
    
      <category term="算法" scheme="http://luojiamingl.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://luojiamingl.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="http://luojiamingl.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis 和 Memcached比较</title>
    <link href="http://luojiamingl.github.io/2018/03/26/Redis%E5%92%8CMemcached%E6%AF%94%E8%BE%83/"/>
    <id>http://luojiamingl.github.io/2018/03/26/Redis和Memcached比较/</id>
    <published>2018-03-26T03:59:22.000Z</published>
    <updated>2018-04-11T11:03:33.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-MySql-Memcached架构的问题"><a href="#1-MySql-Memcached架构的问题" class="headerlink" title="1.  MySql+Memcached架构的问题　　"></a>1.  MySql+Memcached架构的问题　　</h1><hr><p>实际MySQL是适合进行海量数据存储的，通过Memcached将热点数据加载到cache，加速访问，很多公司都曾经使用过这样的架构，但随着业务数据量的不断增加，和访问量的持续增长，我们遇到了很多问题：</p><p><strong>1</strong>.MySQL需要不断进行拆库拆表，Memcached也需不断跟着扩容，扩容和维护工作占据大量开发时间。　</p><p><strong>2</strong>.Memcached与MySQL数据库数据一致性问题。　</p><p><strong>3</strong>.Memcached数据命中率低或down机，大量访问直接穿透到DB，MySQL无法支撑。　　</p><p><strong>4</strong>.跨机房cache同步问题。</p><p>众多NoSQL百花齐放，如何选择</p><p>最近几年，业界不断涌现出很多各种各样的NoSQL产品，那么如何才能正确地使用好这些产品，最大化地发挥其长处，是我们需要深入研究和思考的问题，实际归根结底最重要的是了解这些产品的定位，并且了解到每款产品的tradeoffs，在实际应用中做到扬长避短，总体上这些NoSQL主要用于解决以下几种问题　</p><p><strong>1</strong>.少量数据存储，高速读写访问。此类产品通过数据全部in-momery 的方式来保证高速访问，同时提供数据落地的功能，实际这正是Redis最主要的适用场景。　　</p><p><strong>2</strong>.海量数据存储，分布式系统支持，数据一致性保证，方便的集群节点添加/删除。　　</p><p><strong>3</strong>.这方面最具代表性的是dynamo和bigtable 2篇论文所阐述的思路。前者是一个完全无中心的设计，节点之间通过gossip方式传递集群信息，数据保证最终一致性，后者是一个中心化的方案设计，通过类似一个分布式锁服务来保证强一致性,数据写入先写内存和redo log，然后定期compat归并到磁盘上，将随机写优化为顺序写，提高写入性能。　　</p><p><strong>4</strong>.Schema free，auto-sharding等。比如目前常见的一些文档数据库都是支持schema-free的，直接存储json格式数据，并且支持auto-sharding等功能，比如mongodb。　　</p><p>面对这些不同类型的NoSQL产品,我们需要根据我们的业务场景选择最合适的产品。    </p><p>Redis最适合所有数据in-momory的场景，虽然Redis也提供持久化功能，但实际更多的是一个disk-backed的功能，跟传统意义上的持久化有比较大的差别，那么可能大家就会有疑问，似乎Redis更像一个加强版的Memcached，那么何时使用Memcached,何时使用Redis呢?       如果简单地比较Redis与Memcached的区别，大多数都会得到以下观点：     </p><p><strong>1</strong> 、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。<br><strong>2</strong> 、Redis支持数据的备份，即master-slave模式的数据备份。<br><strong>3</strong> 、Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</p><h1 id="2-Redis常用数据类型"><a href="#2-Redis常用数据类型" class="headerlink" title="2.  Redis常用数据类型"></a>2.  Redis常用数据类型</h1><p>Redis最为常用的数据类型主要有以下：String</p><p>Hash</p><p>List</p><p>Set</p><p>Sorted set</p><p>pub/sub</p><p>Transactions</p><p>在具体描述这几种数据类型之前，我们先通过一张图了解下Redis内部内存管理中是如何描述这些不同数据类型的：  </p><p><img src="1.jpg" alt="image"> </p><p>首先Redis内部使用一个redisObject对象来表示所有的key和value,redisObject最主要的信息如上图所示：        </p><p>type代表一个value对象具体是何种数据类型，         </p><p>encoding是不同数据类型在redis内部的存储方式，</p><p>比如：type=string代表value存储的是一个普通字符串，那么对应的encoding可以是raw或者是int,如果是int则代表实际redis内部是按数值型类存储和表示这个字符串的，当然前提是这个字符串本身可以用数值表示，比如:”123” “456”这样的字符串。       </p><p>这里需要特殊说明一下vm字段，只有打开了Redis的虚拟内存功能，此字段才会真正的分配内存，该功能默认是关闭状态的，该功能会在后面具体描述。</p><p>通过上图我们可以发现Redis使用redisObject来表示所有的key/value数据是比较浪费内存的，当然这些内存管理成本的付出主要也是为了给Redis不同数据类型提供一个统一的管理接口，实际作者也提供了多种方法帮助我们尽量节省内存使用，我们随后会具体讨论。</p><h1 id="3-各种数据类型应用和实现方式"><a href="#3-各种数据类型应用和实现方式" class="headerlink" title="3.  各种数据类型应用和实现方式"></a>3.  各种数据类型应用和实现方式</h1><p>  下面我们先来逐一的分析下这7种数据类型的使用和内部实现方式:</p><h2 id="String-Strings"><a href="#String-Strings" class="headerlink" title="String:Strings"></a>String:Strings</h2><p>数据结构是简单的key-value类型，value其实不仅是String，也可以是数字.常用命令:  set,get,decr,incr,mget 等。</p><p>  应用场景：String是最常用的一种数据类型，普通的key/ value 存储都可以归为此类.即可以完全实现目前 Memcached 的功能，并且效率更高。还可以享受Redis的定时持久化，操作日志及 Replication等功能。</p><p>  除了提供与 Memcached 一样的get、set、incr、decr 等操作外，Redis还提供了下面一些操作：</p><p>  获取字符串长度往字符串append内容</p><p>  设置和获取字符串的某一段内容</p><p>  设置及获取字符串的某一位（bit）</p><p>  批量设置一系列字符串的内容</p><p>  <strong>实现方式</strong>：</p><p>  String在redis内部存储默认就是一个字符串，被redisObject所引用，当遇到incr,decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。</p><h2 id="Hash常用命令：hget-hset-hgetall-等。"><a href="#Hash常用命令：hget-hset-hgetall-等。" class="headerlink" title="Hash常用命令：hget,hset,hgetall 等。"></a>Hash常用命令：hget,hset,hgetall 等。</h2><p>  应用场景：在Memcached中，我们经常将一些结构化的信息打包成HashMap，在客户端序列化后存储为一个字符串的值，比如用户的昵称、年龄、性别、积分等，这时候在需要修改其中某一项时，通常需要将所有值取出反序列化后，修改某一项的值，再序列化存储回去。这样不仅增大了开销，也不适用于一些可能并发操作的场合（比如两个并发的操作都需要修改积分）。而Redis的Hash结构可以使你像在数据库中Update一个属性一样只修改某一项属性值。    </p><p>  我们简单举个实例来描述下Hash的应用场景，比如我们要存储一个用户信息对象数据，包含以下信息：用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储，主要有以下2种存储方式：</p><p><img src="2.jpg" alt="image"></p><p>第一种方式将用户ID作为查找key,把其他信息封装成一个对象以序列化的方式存储，这种方式的缺点是，增加了序列化/反序列化的开销，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS等复杂问题。</p><p><img src="3.jpg" alt="image"></p><p>第二种方法是这个用户信息对象有多少成员就存成多少个key-value对儿，用用户ID+对应属性的名称作为唯一标识来取得对应属性的值，虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费还是非常可观的。那么Redis提供的Hash很好的解决了这个问题，Redis的Hash实际是内部存储的Value为一个HashMap，并提供了直接存取这个Map成员的接口，如下图：</p><p><img src="4.jpg" alt="image"></p><p>也就是说，Key仍然是用户ID, value是一个Map，这个Map的key是成员的属性名，value是属性值，这样对数据的修改和存取都可以直接通过其内部Map的Key(Redis里称内部Map的key为field), 也就是通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。很好的解决了问题。</p><p>这里同时需要注意，Redis提供了接口(hgetall)可以直接取到全部的属性数据,但是如果内部Map的成员很多，那么涉及到遍历整个内部Map的操作，由于Redis单线程模型的缘故，这个遍历操作可能会比较耗时，而另其它客户端的请求完全不响应，这点需要格外注意。</p><p>实现方式：上面已经说到Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为zipmap,当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。</p><h2 id="List常用命令：lpush-rpush-lpop-rpop-lrange等。"><a href="#List常用命令：lpush-rpush-lpop-rpop-lrange等。" class="headerlink" title="List常用命令：lpush,rpush,lpop,rpop,lrange等。"></a>List常用命令：lpush,rpush,lpop,rpop,lrange等。</h2><p>应用场景：Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现。</p><p>Lists 就是链表，相信略有数据结构知识的人都应该能理解其结构。使用Lists结构，我们可以轻松地实现最新消息排行等功能。Lists的另一个应用就是消息队列，可以利用Lists的PUSH操作，将任务存在Lists中，然后工作线程再用POP操作将任务取出进行执行。Redis还提供了操作Lists中某一段的api，你可以直接查询，删除Lists中某一段的元素。</p><p>实现方式：Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。</p><h2 id="Set常用命令：sadd-spop-smembers-sunion-等。"><a href="#Set常用命令：sadd-spop-smembers-sunion-等。" class="headerlink" title="Set常用命令：sadd,spop,smembers,sunion 等。"></a>Set常用命令：sadd,spop,smembers,sunion 等。</h2><p>应用场景：Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p><p>Sets 集合的概念就是一堆不重复值的组合。利用Redis提供的Sets数据结构，可以存储一些集合性的数据，比如在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。</p><p>Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。</p><p>实现方式：set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。</p><h2 id="Sorted-Set常用命令：zadd-zrange-zrem-zcard等"><a href="#Sorted-Set常用命令：zadd-zrange-zrem-zcard等" class="headerlink" title="Sorted Set常用命令：zadd,zrange,zrem,zcard等"></a>Sorted Set常用命令：zadd,zrange,zrem,zcard等</h2><p>使用场景：Redis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。</p><p>当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set数据结构，比如twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。</p><p>另外还可以用Sorted Sets来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。</p><p>实现方式：Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。</p><h2 id="Pub-SubPub-Sub"><a href="#Pub-SubPub-Sub" class="headerlink" title="Pub/SubPub/Sub"></a>Pub/SubPub/Sub</h2><p>从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。</p><p>这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。</p><h2 id="Transactions"><a href="#Transactions" class="headerlink" title="Transactions"></a>Transactions</h2><p>谁说NoSQL都不支持事务，虽然Redis的Transactions提供的并不是严格的ACID的事务（比如一串用EXEC提交执行的命令，在执行中服务器宕机，那么会有一部分命令执行了，剩下的没执行），但是这个Transactions还是提供了基本的命令打包执行的功能（在服务器不出问题的情况下，可以保证一连串的命令是顺序在一起执行的，中间有会有其它客户端命令插进来执行）。</p><p>Redis还提供了一个Watch功能，你可以对一个key进行Watch，然后再执行Transactions，在这过程中，如果这个Watched的值进行了修改，那么这个Transactions会发现并拒绝执行。</p><h1 id="4-Redis实际应用场景"><a href="#4-Redis实际应用场景" class="headerlink" title="4.  Redis实际应用场景"></a>4.  Redis实际应用场景</h1><p>  Redis在很多方面与其他数据库解决方案不同：它使用内存提供主存储支持，而仅使用硬盘做持久性的存储；</p><p>  它的数据模型非常独特，用的是单线程。另一个大区别在于，你可以在开发环境中使用Redis的功能，但却不需要转到Redis。转向Redis当然也是可取的，许多开发者从一开始就把Redis作为首选数据库；但设想如果你的开发环境已经搭建好，应用已经在上面运行了，那么更换数据库框架显然不那么容易。另外在一些需要大容量数据集的应用，Redis也并不适合，因为它的数据集不会超过系统可用的内存。所以如果你有大数据应用，而且主要是读取访问模式，那么Redis并不是正确的选择。  </p><p>  然而我喜欢Redis的一点就是你可以把它融入到你的系统中来，这就能够解决很多问题，比如那些你现有的数据库处理起来感到缓慢的任务。这些你就可以通过Redis来进行优化，或者为应用创建些新的功能。在本文中，我就想探讨一些怎样将Redis加入到现有的环境中，并利用它的原语命令等功能来解决 传统环境中碰到的一些常见问题。</p><p>  在这些例子中，Redis都不是作为首选数据库。</p><h2 id="1、显示最新的项目列表"><a href="#1、显示最新的项目列表" class="headerlink" title="1、显示最新的项目列表"></a>1、显示最新的项目列表</h2><p>下面这个语句常用来显示最新项目，随着数据多了，查询毫无疑问会越来越慢。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM foo WHERE ... ORDER BY time DESC LIMIT 10</span><br></pre></td></tr></table></figure><p>在Web应用中，“列出最新的回复”之类的查询非常普遍，这通常会带来可扩展性问题。这令人沮丧，因为项目本来就是按这个顺序被创建的，但要输出这个顺序却不得不进行排序操作。 </p><p>  类似的问题就可以用Redis来解决。比如说，我们的一个Web应用想要列出用户贴出的最新20条评论。在最新的评论边上我们有一个“显示全部”的链接，点击后就可以获得更多的评论。      </p><p>  我们假设数据库中的每条评论都有一个唯一的递增的ID字段。  </p><p>  我们可以使用分页来制作主页和评论页，使用Redis的模板，每次新评论发表时，我们会将它的ID添加到一个Redis列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH latest.comments &lt;ID&gt;</span><br></pre></td></tr></table></figure></p><p>我们将列表裁剪为指定长度，因此Redis只需要保存最新的5000条评论：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LTRIM latest.comments 0 5000</span><br></pre></td></tr></table></figure><p>  每次我们需要获取最新评论的项目范围时，我们调用一个函数来完成（使用伪代码）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  FUNCTION get_latest_comments(start, num_items):  </span><br><span class="line">    id_list = redis.lrange(&quot;latest.comments&quot;,start,start+num_items - 1)  </span><br><span class="line">    IF id_list.length &lt; num_items  </span><br><span class="line">        id_list = SQL_DB(&quot;SELECT ... ORDER BY time LIMIT ...&quot;)  </span><br><span class="line">    END  </span><br><span class="line">    RETURN id_list  </span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>这里我们做的很简单。在Redis中我们的最新ID使用了常驻缓存，这是一直更新的。但是我们做了限制不能超过5000个ID，因此我们的获取ID函数会一直询问Redis。只有在start/count参数超出了这个范围的时候，才需要去访问数据库。   </p><p>我们的系统不会像传统方式那样“刷新”缓存，Redis实例中的信息永远是一致的。SQL数据库（或是硬盘上的其他类型数据库）只是在用户需要获取“很远”的数据时才会被触发，而主页或第一个评论页是不会麻烦到硬盘上的数据库了。</p><h2 id="2、删除与过滤"><a href="#2、删除与过滤" class="headerlink" title="2、删除与过滤"></a>2、删除与过滤</h2><p>我们可以使用LREM来删除评论。如果删除操作非常少，另一个选择是直接跳过评论条目的入口，报告说该评论已经不存在。</p><p>有些时候你想要给不同的列表附加上不同的过滤器。如果过滤器的数量受到限制，你可以简单的为每个不同的过滤器使用不同的Redis列表。毕竟每个列表只有5000条项目，但Redis却能够使用非常少的内存来处理几百万条项目。</p><h2 id="3、排行榜相关"><a href="#3、排行榜相关" class="headerlink" title="3、排行榜相关"></a>3、排行榜相关</h2><p>另一个很普遍的需求是各种数据库的数据并非存储在内存中，因此在按得分排序以及实时更新这些几乎每秒钟都需要更新的功能上数据库的性能不够理想。      典型的比如那些在线游戏的排行榜，比如一个Facebook的游戏，根据得分你通常想要：</p><ul><li><p>列出前100名高分选手</p></li><li><p>列出某用户当前的全球排名      </p></li></ul><p>这些操作对于Redis来说小菜一碟，即使你有几百万个用户，每分钟都会有几百万个新的得分。</p><p>模式是这样的，每次获得新得分时，我们用这样的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD leaderboard  &lt;score&gt;  &lt;username&gt;</span><br></pre></td></tr></table></figure></p><p>你可能用userID来取代username，这取决于你是怎么设计的。      得到前100名高分用户很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGE leaderboard 0 99</span><br></pre></td></tr></table></figure></p><p>用户的全球排名也相似，只需要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANK leaderboard &lt;username&gt;</span><br></pre></td></tr></table></figure></p><h2 id="4、按照用户投票和时间排序"><a href="#4、按照用户投票和时间排序" class="headerlink" title="4、按照用户投票和时间排序"></a>4、按照用户投票和时间排序</h2><p>排行榜的一种常见变体模式就像Reddit或Hacker News用的那样，新闻按照类似下面的公式根据得分来排序：</p><p>score = points / time^alpha       </p><p>因此用户的投票会相应的把新闻挖出来，但时间会按照一定的指数将新闻埋下去。下面是我们的模式，当然算法由你决定。</p><p>模式是这样的，开始时先观察那些可能是最新的项目，例如首页上的1000条新闻都是候选者，因此我们先忽视掉其他的，这实现起来很简单。  </p><p>每次新的新闻贴上来后，我们将ID添加到列表中，使用LPUSH + LTRIM，确保只取出最新的1000条项目。   </p><p>有一项后台任务获取这个列表，并且持续的计算这1000条新闻中每条新闻的最终得分。计算结果由ZADD命令按照新的顺序填充生成列表，老新闻则被清除。这里的关键思路是排序工作是由后台任务来完成的。</p><h2 id="5、处理过期项目"><a href="#5、处理过期项目" class="headerlink" title="5、处理过期项目"></a>5、处理过期项目</h2><p>另一种常用的项目排序是按照时间排序。我们使用unix时间作为得分即可。      </p><p>模式如下：       </p><ul><li><p>每次有新项目添加到我们的非Redis数据库时，我们把它加入到排序集合中。这时我们用的是时间属性，current_time和time_to_live。       </p></li><li><p>另一项后台任务使用ZRANGE…SCORES查询排序集合，取出最新的10个项目。如果发现unix时间已经过期，则在数据库中删除条目。</p></li></ul><h2 id="6、计数"><a href="#6、计数" class="headerlink" title="6、计数"></a>6、计数</h2><p>Redis是一个很好的计数器，这要感谢INCRBY和其他相似命令。       </p><p>我相信你曾许多次想要给数据库加上新的计数器，用来获取统计或显示新信息，但是最后却由于写入敏感而不得不放弃它们。       </p><p>好了，现在使用Redis就不需要再担心了。有了原子递增（atomic increment），你可以放心的加上各种计数，用GETSET重置，或者是让它们过期。       例如这样操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR user:&lt;id&gt; EXPIRE user:&lt;id&gt; 60</span><br></pre></td></tr></table></figure></p><p>你可以计算出最近用户在页面间停顿不超过60秒的页面浏览量，当计数达到比如20时，就可以显示出某些条幅提示，或是其它你想显示的东西。</p><h2 id="7、特定时间内的特定项目"><a href="#7、特定时间内的特定项目" class="headerlink" title="7、特定时间内的特定项目"></a>7、特定时间内的特定项目</h2><p>另一项对于其他数据库很难，但Redis做起来却轻而易举的事就是统计在某段特点时间里有多少特定用户访问了某个特定资源。比如我想要知道某些特定的注册用户或IP地址，他们到底有多少访问了某篇文章。</p><p>每次我获得一次新的页面浏览时我只需要这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SADD page:day1:&lt;page_id&gt; &lt;user_id&gt;</span><br></pre></td></tr></table></figure></p><p>当然你可能想用unix时间替换day1，比如time()-(time()%3600*24)等等。 </p><p>想知道特定用户的数量吗？只需要使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCARD page:day1:&lt;page_id&gt;</span><br></pre></td></tr></table></figure></p><p>需要测试某个特定用户是否访问了这个页面？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SISMEMBER page:day1:&lt;page_id&gt;</span><br></pre></td></tr></table></figure></p><h2 id="8、实时分析正在发生的情况"><a href="#8、实时分析正在发生的情况" class="headerlink" title="8、实时分析正在发生的情况"></a>8、实时分析正在发生的情况</h2><p>用于数据统计与防止垃圾邮件等        我们只做了几个例子，但如果你研究Redis的命令集，并且组合一下，就能获得大量的实时分析方法，有效而且非常省力。使用Redis原语命令，更容易实施垃圾邮件过滤系统或其他实时跟踪系统。</p><h2 id="9、Pub-Sub"><a href="#9、Pub-Sub" class="headerlink" title="9、Pub/Sub"></a>9、Pub/Sub</h2><p>Redis的Pub/Sub非常非常简单，运行稳定并且快速。支持模式匹配，能够实时订阅与取消频道。</p><h2 id="10、队列"><a href="#10、队列" class="headerlink" title="10、队列"></a>10、队列</h2><p>你应该已经注意到像list push和list pop这样的Redis命令能够很方便的执行队列操作了，但能做的可不止这些：比如Redis还有list pop的变体命令，能够在列表为空时阻塞队列。</p><p>现代的互联网应用大量地使用了消息队列（Messaging）。消息队列不仅被用于系统内部组件之间的通信，同时也被用于系统跟其它服务之间的交互。</p><p>消息队列的使用可以增加系统的可扩展性、灵活性和用户体验。</p><p>非基于消息队列的系统，其运行速度取决于系统中最慢的组件的速度（注：短板效应）。而基于消息队列可以将系统中各组件解除耦合，这样系统就不再受最慢组件的束缚，各组件可以异步运行从而得以更快的速度完成各自的工作。   </p><p>此外，当服务器处在高并发操作的时候，比如频繁地写入日志文件。可以利用消息队列实现异步处理。从而实现高性能的并发操作。</p><h2 id="11、缓存"><a href="#11、缓存" class="headerlink" title="11、缓存"></a>11、缓存</h2><p>Redis的缓存部分值得写一篇新文章，我这里只是简单的说一下。Redis能够替代memcached，让你的缓存从只能存储数据变得能够更新数据，因此你不再需要每次都重新生成数据了。</p><h1 id="数据持久化支持"><a href="#数据持久化支持" class="headerlink" title="数据持久化支持"></a>数据持久化支持</h1><p>Redis虽然是基于内存的存储系统，但是它本身是支持内存数据的持久化的，而且提供两种主要的持久化策略：RDB快照和AOF日志。</p><p>而memcached是不支持数据持久化操作的。</p><h2 id="1）RDB快照"><a href="#1）RDB快照" class="headerlink" title="1）RDB快照"></a>1）RDB快照</h2><p>Redis支持将当前数据的快照存成一个数据文件的持久化机制，即RDB快照。但是一个持续写入的数据库如何生成快照呢？</p><p>Redis借助了fork命令的copy on write机制。在生成快照时，将当前进程fork出一个子进程，然后在子进程中循环所有的数据，将数据写成为RDB文件。</p><p>我们可以通过Redis的save指令来配置RDB快照生成的时机，比如配置10分钟就生成快照，也可以配置有1000次写入就生成快照，也可以多个规则一起实施。</p><p>这些规则的定义就在Redis的配置文件中，你也可以通过Redis的CONFIG SET命令在Redis运行时设置规则，不需要重启Redis。</p><p>Redis的RDB文件不会坏掉，因为其写操作是在一个新进程中进行的，当生成一个新的RDB文件时，Redis生成的子进程会先将数据写到一个临时文件中，然后通过原子性rename系统调用将临时文件重命名为RDB文件，这样在任何时候出现故障，Redis的RDB文件都总是可用的。</p><p>同时，Redis的RDB文件也是Redis主从同步内部实现中的一环。RDB有他的不足，就是一旦数据库出现问题，那么我们的RDB文件中保存的数据并不是全新的，从上次RDB文件生成到Redis停机这段时间的数据全部丢掉了。在某些业务下，这是可以忍受的。</p><h2 id="2）AOF日志"><a href="#2）AOF日志" class="headerlink" title="2）AOF日志"></a>2）AOF日志</h2><p>AOF日志的全称是append only file，它是一个追加写入的日志文件。与一般数据库的binlog不同的是，AOF文件是可识别的纯文本，它的内容就是一个个的Redis标准命令。只有那些会导致数据发生修改的命令才会追加到AOF文件。每一条修改数据的命令都生成一条日志。</p><p>AOF文件会越来越大，所以Redis又提供了一个功能，叫做AOF rewrite。其功能就是重新生成一份AOF文件，新的AOF文件中一条记录的操作只会有一次，而不像一份老文件那样，可能记录了对同一个值的多次操作。其生成过程和RDB类似，也是fork一个进程，直接遍历数据，写入新的AOF临时文件。</p><p>在写入新文件的过程中，所有的写操作日志还是会写到原来老的AOF文件中，同时还会记录在内存缓冲区中。当重完操作完成后，会将所有缓冲区中的日志一次性写入到临时文件中。然后调用原子性的rename命令用新的AOF文件取代老的AOF文件。</p><p>AOF是一个写文件操作，其目的是将操作日志写到磁盘上，所以它也同样会遇到我们上面说的写操作的流程。在Redis中对AOF调用write写入后，通过appendfsync选项来控制调用fsync将其写到磁盘上的时间，下面appendfsync的三个设置项，安全强度逐渐变强。</p><p><strong>appendfsync no</strong></p><p>当设置appendfsync为no的时候，Redis不会主动调用fsync去将AOF日志内容同步到磁盘，所以这一切就完全依赖于操作系统的调试了。对大多数Linux操作系统，是每30秒进行一次fsync，将缓冲区中的数据写到磁盘上。</p><p><strong>appendfsync everysec</strong></p><p>当设置appendfsync为everysec的时候，Redis会默认每隔一秒进行一次fsync调用，将缓冲区中的数据写到磁盘。但是当这一次的fsync调用时长超过1秒时。Redis会采取延迟fsync的策略，再等一秒钟。也就是在两秒后再进行fsync，这一次的fsync就不管会执行多长时间都会进行。这时候由于在fsync时文件描述符会被阻塞，所以当前的写操作就会阻塞。</p><p>所以结论就是，在绝大多数情况下，Redis会每隔一秒进行一次fsync。在最坏的情况下，两秒钟会进行一次fsync操作。这一操作在大多数数据库系统中被称为group commit，就是组合多次写操作的数据，一次性将日志写到磁盘。</p><p><strong>appednfsync always</strong></p><p>当设置appendfsync为always时，每一次写操作都会调用一次fsync，这时数据是最安全的，当然，由于每次都会执行fsync，所以其性能也会受到影响。</p><p>对于一般性的业务需求，建议使用RDB的方式进行持久化，原因是RDB的开销并相比AOF日志要低很多，对于那些无法忍数据丢失的应用，建议使用AOF日志。</p><h1 id="集群管理的不同"><a href="#集群管理的不同" class="headerlink" title="集群管理的不同"></a>集群管理的不同</h1><p>Memcached是全内存的数据缓冲系统，Redis虽然支持数据的持久化，但是全内存毕竟才是其高性能的本质。</p><p>作为基于内存的存储系统来说，机器物理内存的大小就是系统能够容纳的最大数据量。如果需要处理的数据量超过了单台机器的物理内存大小，就需要构建分布式集群来扩展存储能力。</p><p>Memcached本身并不支持分布式，因此只能在客户端通过像一致性哈希这样的分布式算法来实现Memcached的分布式存储。</p><p>当客户端向Memcached集群发送数据之前，首先会通过内置的分布式算法计算出该条数据的目标节点，然后数据会直接发送到该节点上存储。但客户端查询数据时，同样要计算出查询数据所在的节点，然后直接向该节点发送查询请求以获取数据。</p><p>相较于Memcached只能采用客户端实现分布式存储，Redis更偏向于在服务器端构建分布式存储。最新版本的Redis已经支持了分布式存储功能。</p><p>Redis Cluster是一个实现了分布式且允许单点故障的Redis高级版本，它没有中心节点，具有线性可伸缩的功能。</p><p>Redis Cluster将整个key的数值域分成4096个哈希槽，每个节点上可以存储一个或多个哈希槽，也就是说当前Redis</p><p>Cluster支持的最大节点数就是4096。</p><p>Redis Cluster使用的分布式算法也很简单：crc16( key ) % HASH_SLOTS_NUMBER。</p><p>为了保证单点故障下的数据可用性，Redis Cluster引入了Master节点和Slave节点。</p><p>在Redis Cluster中，每个Master节点都会有对应的两个用于冗余的Slave节点。</p><p>这样在整个集群中，任意两个节点的宕机都不会导致数据的不可用。当Master节点退出后，集群会自动选择一个Slave节点成为新的Master节点。</p><h3 id="有问题可以联系博主。"><a href="#有问题可以联系博主。" class="headerlink" title="有问题可以联系博主。"></a><strong>有问题可以联系博主</strong>。</h3><h3 id="转载请注明出处，谢谢！"><a href="#转载请注明出处，谢谢！" class="headerlink" title="转载请注明出处，谢谢！"></a><strong>转载请注明出处，谢谢</strong>！</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-MySql-Memcached架构的问题&quot;&gt;&lt;a href=&quot;#1-MySql-Memcached架构的问题&quot; class=&quot;headerlink&quot; title=&quot;1.  MySql+Memcached架构的问题　　&quot;&gt;&lt;/a&gt;1.  MySql+Memcac
      
    
    </summary>
    
      <category term="redis" scheme="http://luojiamingl.github.io/categories/redis/"/>
    
    
      <category term="redis" scheme="http://luojiamingl.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>grep统计某个单词的个数，行数等</title>
    <link href="http://luojiamingl.github.io/2018/03/12/grep%E7%BB%9F%E8%AE%A1%E6%9F%90%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E4%B8%AA%E6%95%B0%EF%BC%8C%E8%A1%8C%E6%95%B0%E7%AD%89/"/>
    <id>http://luojiamingl.github.io/2018/03/12/grep统计某个单词的个数，行数等/</id>
    <published>2018-03-12T03:59:22.000Z</published>
    <updated>2018-04-11T11:03:33.651Z</updated>
    
    <content type="html"><![CDATA[<p>文件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">j@j:~$ cat hello.c</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">//include include</span><br><span class="line">int main()&#123;</span><br><span class="line">  printf(&quot;hello world/n&quot;);</span><br><span class="line">  exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>grep命令查看include关键词</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">j@j:~$ grep -o include  hello.c</span><br><span class="line">include</span><br><span class="line">include</span><br><span class="line">include</span><br></pre></td></tr></table></figure><p>如上所示， 所有的include都显示出来了， 包括有两个include的行。</p><p>命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -c -o include  hello.c</span><br></pre></td></tr></table></figure></p><p>的结果是2， -c参数只能统计行。如果要统计个数， 可以再来个重定向：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -o include hello.c| grep -c include</span><br></pre></td></tr></table></figure><p>得到include的个数 3</p><h3 id="有问题可以联系博主。"><a href="#有问题可以联系博主。" class="headerlink" title="有问题可以联系博主。"></a><strong>有问题可以联系博主</strong>。</h3><h3 id="转载请注明出处，谢谢！"><a href="#转载请注明出处，谢谢！" class="headerlink" title="转载请注明出处，谢谢！"></a><strong>转载请注明出处，谢谢</strong>！</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文件内容&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br
      
    
    </summary>
    
      <category term="linux" scheme="http://luojiamingl.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://luojiamingl.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>使用meerkat进行服务监控和服务降级</title>
    <link href="http://luojiamingl.github.io/2018/01/29/%E4%BD%BF%E7%94%A8meerkat%E8%BF%9B%E8%A1%8C%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7/"/>
    <id>http://luojiamingl.github.io/2018/01/29/使用meerkat进行服务监控和服务降级/</id>
    <published>2018-01-29T03:59:22.000Z</published>
    <updated>2018-04-11T11:03:33.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="meerkat进行服务监控和服务降级"><a href="#meerkat进行服务监控和服务降级" class="headerlink" title="meerkat进行服务监控和服务降级"></a>meerkat进行服务监控和服务降级</h1><p>meerkat 是用于服务监控以及服务降级基础组件，主要为了解决调用外部接口的时候进行成功率，响应时间，QPS指标的监控，同时在成功率下降到预设的阈值以下的时候自动切断外部接口的调用，外部接口成功率恢复后自动恢复请求。本文将对使用方式以及进阶特性进行介绍。</p><p>项目主页： <a href="https://github.com/ChanningBJ" target="_blank" rel="noopener">https://github.com/ChanningBJ</a>…</p><h2 id="为什么要进行监控和熔断"><a href="#为什么要进行监控和熔断" class="headerlink" title="为什么要进行监控和熔断"></a>为什么要进行监控和熔断</h2><p>在我们的Java服务中，经常会调用外部的一些接口进行数据的获取操作，当这些外部接口的成功率比较低的时候会直接影响到服务本身的成功率，因此我们添加了对外部接口调用的成功率和响应时间监控，这样可以在造成大量用户影响之前预先发现并解决问题。同时，对于接口中的非关键数据，我们采取了更具成功率判断进行触发熔断的方式，当成功率下降到预定的阀值以下的时候自动停止对这个外部接口的访问以便保证关键数据能够正常提供，当成功率恢复以后自动恢复请求。</p><h2 id="meerkat主要功能"><a href="#meerkat主要功能" class="headerlink" title="meerkat主要功能"></a>meerkat主要功能</h2><p>监控：监控Java内部操作的成功率以及响应时间指标<br>上报：log文件和Grafhite两种监控指标上报方式，支持扩展其他的上报方式<br>熔断：（可选功能）成功率下降到预设的阈值以下触发熔断保护，暂定对外部接口的访问，成功率恢复以后自动恢复访问</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.channingbj&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;meerkat&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="定义受监控的操作"><a href="#定义受监控的操作" class="headerlink" title="定义受监控的操作"></a>定义受监控的操作</h3><p>假设我们的服务中需要从HTTP接口查询一个节目的播放次数，为了防止这个HTTP接口大量超时影响我们自身服务的质量，可以定义一个查询Command：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class GetPlayCountCommand extends FusingCommand&lt;Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final Long videoID;</span><br><span class="line"></span><br><span class="line">    public GetPlayCountCommand(Long videoID) &#123;</span><br><span class="line">        this.videoID = videoID;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    protected Optional&lt;Long&gt; run() &#123;</span><br><span class="line">        Long result = 0l;</span><br><span class="line">        // 调用HTTP接口获取视频的播放次数信息</span><br><span class="line">        // 如果调用失败，返回 null 或者抛出异常，会将这次操作记录为失败</span><br><span class="line">        // 如果ID非法，返回 Optional.absent(),会将这次操作记录为成功</span><br><span class="line">        return Optional.fromNullable(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">执行查询：</span><br><span class="line"></span><br><span class="line">//获取视频ID为123的视频的播放次数</span><br><span class="line">GetPlayCountCommand command = new GetPlayCountCommand(123l);</span><br><span class="line">Long result = command.execute(); // 执行查询操作，如果执行失败或者处于熔断状态，返回 null</span><br></pre></td></tr></table></figure></p><h2 id="配置监控上报"><a href="#配置监控上报" class="headerlink" title="配置监控上报"></a>配置监控上报</h2><p>在服务初始化的时候需要对监控上报进行设置。下面的例子中开启了监控数据向日志文件的打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MeterCenter.INSTANCE</span><br><span class="line">    .enableReporter(new EnablingLogReporter(&quot;org.apache.log4j.RollingFileAppender&quot;))</span><br><span class="line">    .init();</span><br></pre></td></tr></table></figure></p><h2 id="查看统计结果"><a href="#查看统计结果" class="headerlink" title="查看统计结果"></a>查看统计结果</h2><p>统计结果会以熔断命令类名为进行分组。例如前面我们定义的 GetPlayCountCommand 类,package name 是 com.test，那么在日志中的输出将会是这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type=GAUGE, name=com.test.GetPlayCountCommand.normal-rate, value=0.0</span><br><span class="line">type=GAUGE, name=com.test.GetPlayCountCommand.success-rate, value=61.0</span><br><span class="line">type=TIMER, name=com.test.GetPlayCountCommand.time, count=25866500, min=0.0, max=0.001, mean=3.963926781047921E-5, stddev=1.951102156677818E-4, median=0.0, p75=0.0, p95=0.0, p98=0.001, p99=0.001, p999=0.001, mean_rate=649806.0831335272, m1=1665370.7316699813, m5=2315813.300713087, m15=2446572.324069477, rate_unit=events/second, duration_unit=milliseconds</span><br></pre></td></tr></table></figure><h2 id="单独使用监控功能"><a href="#单独使用监控功能" class="headerlink" title="单独使用监控功能"></a>单独使用监控功能</h2><p>如果不想使用熔断功能，只是想监控Java方法调用的耗时和成功率，可以直接使用 OperationMeter 进行实现，只需要在函数调用的前后添加开始和结束的调用即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//创建一个操作的计数器</span><br><span class="line">    OperationMeter meter = MeterCenter.INSTANCE.getOrCreateMeter(OperationMeterTest.class, OperationMeter.class);</span><br><span class="line"></span><br><span class="line">    //模拟成功率60%</span><br><span class="line">    for(int k=0; k&lt;100; k++)&#123;</span><br><span class="line">        Timer.Context context = meter.startOperation();</span><br><span class="line">        if(k%10&lt;6)&#123;</span><br><span class="line">            meter.endOperation(context, OperationMeter.Result.SUCCESS);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            meter.endOperation(context, OperationMeter.Result.FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="开启熔断并配置阀值和持续时间"><a href="#开启熔断并配置阀值和持续时间" class="headerlink" title="开启熔断并配置阀值和持续时间"></a>开启熔断并配置阀值和持续时间</h2><p>首先创建一个接口，继承自FusingConfig，用于指定配置文件的加载路径，同时还可以设定配置文件的刷新时间，具体定义方法请参照 <a href="http://owner.aeonbits.org/" target="_blank" rel="noopener">++owner++</a> 文档<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Config.Sources(&quot;classpath:app_config.properties&quot;)</span><br><span class="line">@Config.HotReload(</span><br><span class="line">        value = 1, unit = java.util.concurrent.TimeUnit.MINUTES,</span><br><span class="line">        type = Config.HotReloadType.ASYNC)</span><br><span class="line">public interface APPFusingConfig extends FusingConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建查询Command的时候在构造函数中传入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class GetPlayCountCommand extends FusingCommand&lt;Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final Long videoID;</span><br><span class="line"></span><br><span class="line">    public GetPlayCountCommand(Long videoID) &#123;</span><br><span class="line">        super( APPFusingConfig.class);  //设定配置文件</span><br><span class="line">        this.videoID = videoID;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    protected Optional&lt;Long&gt; run() &#123;</span><br><span class="line">        Long result = 0l;</span><br><span class="line">        // 调用HTTP接口获取视频的播放次数信息</span><br><span class="line">        // 如果调用失败，返回 null 或者抛出异常，会将这次操作记录为失败</span><br><span class="line">        // 如果ID非法，返回 Optional.absent(),会将这次操作记录为成功</span><br><span class="line">        return Optional.fromNullable(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>配置文件内容如下：</p><table><thead><tr><th>监控项</th><th>含义</th><th>默认值</th></tr></thead><tbody><tr><td>fusing.[CommandClassName].mode</td><td>熔断模式：FORCE_NORMAL－关闭熔断功能;AUTO_FUSING－自动进入熔断模式;FORCE_NORMAL－强制进行熔断</td><td>FORCE_NORMAL</td></tr><tr><td>fusing.[CommandClassName].duration</td><td>触发一次熔断以后持续的时间，支持ms,sec,min 单位。例如 10sec</td><td>50sec</td></tr><tr><td>fusing.[CommandClassName].success_rate_threshold</td><td>触发熔断的成功率阀值，降低到这个成功率以下将触发熔断，例如0.9表示成功率90%</td><td>0.9</td></tr></tbody></table><p>配置文件中的 CommandClassName 是每个操作类的名称，可以为每个操作单独设置上述参数。同时，这个配置文件支持动态加载，乐意通过修改fusing.[CommandClassName].mode 手工触发或者关闭熔断。</p><h2 id="监控指标上报Graphite"><a href="#监控指标上报Graphite" class="headerlink" title="监控指标上报Graphite"></a>监控指标上报Graphite</h2><p>我们的服务中使用的是Metric+Graphite+Gafana进行监控数据的采集存储和展现，下面将介绍如何配置监控数据上报Grafana，关于Graphite+Grafana的配置，可以参考文章：使用<a href="https://segmentfault.com/a/1190000007540752" target="_blank" rel="noopener">graphite和grafana进行应用程序监控</a></p><h2 id="定义配置文件"><a href="#定义配置文件" class="headerlink" title="定义配置文件"></a>定义配置文件</h2><p>首先定义一个接口，继承自GraphiteReporterConfig，通过这个接口定义配置文件的加载路径。配置文件路径的定义方法请参照 <a href="http://owner.aeonbits.org/" target="_blank" rel="noopener">++owner++</a>  文档, 下面是一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Config.Sources(&quot;classpath:config.properties&quot;)</span><br><span class="line">public interface MyConfig extends GraphiteReporterConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>配置文件中需要定义下列内容：</p><table><thead><tr><th>配置项</th><th>含义</th></tr></thead><tbody><tr><td>meter.reporter.enabled.hosts</td><td>开启监控上报的服务器列表</td></tr><tr><td>meter.reporter.perfix</td><td>上报使用的前缀</td></tr><tr><td>meter.reporter.carbon.host</td><td>grafana(carbon-cache) 的 IP 地址，用于存储监控数据</td></tr><tr><td>meter.reporter.carbon.port</td><td>grafana(carbon-cache) 的端口</td></tr></tbody></table><p>下面这个例子是在192.168.0.0.1和192.168.0.0.2两台服务器上开启监控数据上报，上报监控指标的前缀是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">project_name.dc：</span><br><span class="line"></span><br><span class="line">meter.reporter.enabled.hosts = 192.168.0.0.1,192.168.0.0.2</span><br><span class="line">meter.reporter.perfix = project_name.dc</span><br><span class="line">meter.reporter.carbon.host = hostname.graphite</span><br></pre></td></tr></table></figure></p><p>由于相同机房的不同服务器对外部接口的访问情况一般比较类似，所以仅选取部分机器上报，也是为了节省资源。仅选择部分机器上报不影响熔断效果。</p><h2 id="初始化配置上报"><a href="#初始化配置上报" class="headerlink" title="初始化配置上报"></a>初始化配置上报</h2><p>在服务初始化的时候需要对监控上报进行设置。下面的例子中开启了监控数据向日志文件的打印，同时通过MyConfig指定的配置文件加载Graphite配置信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MeterCenter.INSTANCE</span><br><span class="line">    .enableReporter(new EnablingLogReporter(&quot;org.apache.log4j.RollingFileAppender&quot;))</span><br><span class="line">    .enableReporter(new EnablingGraphiteReporter(MyConfig.class))   //监控数据上报Grafana</span><br><span class="line">    .init();</span><br></pre></td></tr></table></figure></p><h2 id="查看统计结果-1"><a href="#查看统计结果-1" class="headerlink" title="查看统计结果"></a>查看统计结果</h2><p>统计结果会以熔断命令类名为进行分组。例如前面我们定义的 GetPlayCountCommand 类,package name 是 com.test，那么在日志中的输出将会是这个样子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type=GAUGE, name=com.test.GetPlayCountCommand.normal-rate, value=0.0</span><br><span class="line">type=GAUGE, name=com.test.GetPlayCountCommand.success-rate, value=61.0</span><br><span class="line">type=TIMER, name=com.test.GetPlayCountCommand.time, count=25866500, min=0.0, max=0.001, mean=3.963926781047921E-5, stddev=1.951102156677818E-4, median=0.0, p75=0.0, p95=0.0, p98=0.001, p99=0.001, p999=0.001, mean_rate=649806.0831335272, m1=1665370.7316699813, m5=2315813.300713087, m15=2446572.324069477, rate_unit=events/second, duration_unit=milliseconds</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>监控项</th><th>含义</th></tr></thead><tbody><tr><td>[classname].success-rate</td><td>成功率</td></tr><tr><td>[classname].time.m1</td><td>QPS</td></tr><tr><td>[classname].time.mean</td><td>平均响应时间</td></tr><tr><td>[classname].normal-rate</td><td>过去1分钟内处于正常访问（非熔断）的时间比例</td></tr></tbody></table><p>在Grafanna中可以看到下面的监控图：<br><img src="alert.png" alt="image"></p><h2 id="自定义监控上报"><a href="#自定义监控上报" class="headerlink" title="自定义监控上报"></a>自定义监控上报</h2><p>meerkat使用<a href="http://metrics.dropwizard.io/" target="_blank" rel="noopener">++Metrics++</a>进行监控数据的统计，因此可以使用Metrics支持的所有reporter进行上报。添加一种上报的时候，只需要实现 EnablingReporter 并在 MeterCenter 初始化之前进行调用即可。下面是log reporter的实现，可以作为参考<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class EnablingLogReporter implements EnablingReporter &#123;</span><br><span class="line">    private String loggername;</span><br><span class="line"></span><br><span class="line">    public EnablingLogReporter(String loggername) &#123;</span><br><span class="line">        this.loggername = loggername;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void invoke(MetricRegistry metricRegistry, long period, TimeUnit timeUnit) &#123;</span><br><span class="line">        Slf4jReporter.forRegistry(metricRegistry)</span><br><span class="line">                .outputTo(LoggerFactory.getLogger(loggername))</span><br><span class="line">                .convertRatesTo(java.util.concurrent.TimeUnit.SECONDS)</span><br><span class="line">                .convertDurationsTo(java.util.concurrent.TimeUnit.MILLISECONDS)</span><br><span class="line">                .build().start(period, timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>MeterCenter 初始化的时候开启reporter<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MeterCenter.INSTANCE</span><br><span class="line">    .enableReporter(new EnablingLogReporter(&quot;org.apache.log4j.RollingFileAppender&quot;))</span><br><span class="line">    .init();</span><br></pre></td></tr></table></figure></p><h2 id="多实例监控"><a href="#多实例监控" class="headerlink" title="多实例监控"></a>多实例监控</h2><p>多实例监控主要是为了解决一个被监控操作的实现类需要根据输入参数的不同分别进行监控和熔断的情况，通过定义实例的名称进行实现。例如获取视频播放次数的例子，获取视频播放次数的接口对于不同的视频类型而言请求逻辑是一样的，所以使用同一个类进行实现；但是对于不同的视频类型，接口实现的复杂程度不同导致成功率不同，当用户上传的视频的播次接口大量失败的时候我们不希望同时熔断电影电视剧这类视频的播放次数获取，这时就需要使用多实例这种特性进行监控和熔断。</p><p>下面是一个单实例的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class GetPlayCountCommand extends FusingCommand&lt;Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final Long videoID;</span><br><span class="line"></span><br><span class="line">    public GetPlayCountCommand(Long videoID) &#123;</span><br><span class="line">        super( APPFusingConfig.class);</span><br><span class="line">        this.videoID = videoID;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    protected Optional&lt;Long&gt; run() &#123;</span><br><span class="line">        Long result = 0l;</span><br><span class="line">        // 调用HTTP接口获取视频的播放次数信息</span><br><span class="line">        // 如果调用失败，返回 null 或者抛出异常，会将这次操作记录为失败</span><br><span class="line">        // 如果ID非法，返回 Optional.absent(),会将这次操作记录为成功</span><br><span class="line">        return Optional.fromNullable(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设业务上我们可以根据视频ID判断视频类型，可以在类初始化的时候根据类型创建多种监控实例，添加了多实例支持的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class GetPlayCountCommand extends FusingCommand&lt;Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final Long videoID;</span><br><span class="line"></span><br><span class="line">    public GetPlayCountCommand(Long videoID) &#123;</span><br><span class="line">        super( getVideoType(videoID), APPFusingConfig.class);</span><br><span class="line">        this.videoID = videoID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String getVideoType(Long videoID)&#123;</span><br><span class="line">        return &quot;PGC&quot;; //根据videoID进行判断，返回 &quot;PGC&quot; 或者 &quot;UGC&quot; 这两个类别</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Optional&lt;Long&gt; run() &#123;</span><br><span class="line">        Long result = 0l;</span><br><span class="line">        // 调用HTTP接口获取视频的播放次数信息</span><br><span class="line">        // 如果调用失败，返回 null 或者抛出异常，会将这次操作记录为失败</span><br><span class="line">        // 如果ID非法，返回 Optional.absent(),会将这次操作记录为成功</span><br><span class="line">        return Optional.fromNullable(result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>由于每个实例独享一个监控指标，日志中的监控个结果是这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type=GAUGE, name=com.test.GetPlayCountCommand.PGC.normal-rate, value=100.0</span><br><span class="line">type=GAUGE, name=com.test.GetPlayCountCommand.PGC.success-rate, value=100.0</span><br><span class="line">type=GAUGE, name=com.test.GetPlayCountCommand.UGC.normal-rate, value=100.0</span><br><span class="line">type=GAUGE, name=com.test.GetPlayCountCommand.UGC.success-rate, value=60.0</span><br><span class="line">type=TIMER, name=com.test.GetPlayCountCommand.PGC.time, count=100, min=0.0, max=0.509, mean=0.00635, stddev=0.05052135687013958, median=0.001, p75=0.002, p95=0.002, p98=0.003, p99=0.003, p999=0.509, mean_rate=1.6680162586215173, m1=8.691964170141569, m5=16.929634497812284, m15=18.919189378135307, rate_unit=events/second, duration_unit=milliseconds</span><br><span class="line">type=TIMER, name=com.test.GetPlayCountCommand.UGC.time, count=100, min=0.0, max=0.027, mean=0.00132, stddev=0.0026939933184772376, median=0.001, p75=0.001, p95=0.002, p98=0.005, p99=0.006, p999=0.027, mean_rate=1.6715904477699361, m1=8.691964170141569, m5=16.929634497812284, m15=18.919189378135307, rate_unit=events/second, duration_unit=milliseconds</span><br></pre></td></tr></table></figure><p>相应的，对熔断阀值以及持续时间的配置也需要明确指出实例的名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fusing.GetPlayCountCommand.UGC.mode = AUTO_FUSING</span><br><span class="line">fusing.GetPlayCountCommand.UGC.duration = 50sec</span><br><span class="line">fusing.GetPlayCountCommand.UGC.success_rate_threshold = 0.9</span><br><span class="line"></span><br><span class="line">fusing.GetPlayCountCommand.PGC.mode = AUTO_FUSING</span><br><span class="line">fusing.GetPlayCountCommand.PGC.duration = 50sec</span><br><span class="line">fusing.GetPlayCountCommand.PGC.success_rate_threshold = 0.9</span><br></pre></td></tr></table></figure><p>参考资料<br><a href="https://segmentfault.com/a/1190000009730789" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009730789</a></p><h3 id="有问题可以联系博主。"><a href="#有问题可以联系博主。" class="headerlink" title="有问题可以联系博主。"></a><strong>有问题可以联系博主</strong>。</h3><h3 id="转载请注明出处，谢谢！"><a href="#转载请注明出处，谢谢！" class="headerlink" title="转载请注明出处，谢谢！"></a><strong>转载请注明出处，谢谢</strong>！</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;meerkat进行服务监控和服务降级&quot;&gt;&lt;a href=&quot;#meerkat进行服务监控和服务降级&quot; class=&quot;headerlink&quot; title=&quot;meerkat进行服务监控和服务降级&quot;&gt;&lt;/a&gt;meerkat进行服务监控和服务降级&lt;/h1&gt;&lt;p&gt;meerka
      
    
    </summary>
    
      <category term="java" scheme="http://luojiamingl.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://luojiamingl.github.io/tags/java/"/>
    
      <category term="熔断" scheme="http://luojiamingl.github.io/tags/%E7%86%94%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>shell中条件判断if中的-a到-z的意思</title>
    <link href="http://luojiamingl.github.io/2018/01/10/shell%E4%B8%AD%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%ADif%E4%B8%AD%E7%9A%84-a%E5%88%B0-z%E7%9A%84%E6%84%8F%E6%80%9D/"/>
    <id>http://luojiamingl.github.io/2018/01/10/shell中条件判断if中的-a到-z的意思/</id>
    <published>2018-01-10T11:59:22.000Z</published>
    <updated>2018-04-11T11:03:33.683Z</updated>
    
    <content type="html"><![CDATA[<p>shell中条件判断if中的-a到-z的意思</p><a id="more"></a><p>[-a file] 如果file存在则为真 </p><p>[-b file] 如果file存在且是一个块特殊文件则为真 </p><p>[-c file] 如果file存在且是一个字特殊文件则为真 </p><p>[-d file] 如果file文件存在且是一个目录则为真<br>-d前的!是逻辑非<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if [ ! -d $lcd_path/$par_date ]</span><br></pre></td></tr></table></figure></p><p>表示后面的那个目录不存在，则执行后面的then操作 </p><p>[-e file] 如果file文件存在则为真 </p><p>[-f file] 如果file存在且是一个普通文件则为真 </p><p>[-g file] 如果file存在且已经设置了SGID则为真（SUID 是 Set User ID, SGID 是 Set Group ID的意思） </p><p>[-h file] 如果file存在且是一个符号连接则为真 </p><p>[-k file] 如果file存在且已经设置粘制位则为真<br>当一个目录被设置为”粘制位”(用chmod a+t),则该目录下的文件只能由<br>一、超级管理员删除<br>二、该目录的所有者删除<br>三、该文件的所有者删除<br>也就是说,即便该目录是任何人都可以写,但也只有文件的属主才可以删除文件。<br>具体例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ls -dl /tmp </span><br><span class="line">drwxrwxrwt 4 root    root </span><br><span class="line">.........</span><br></pre></td></tr></table></figure></p><p>注意other位置的t，这便是粘连位。 </p><p>[-p file] 如果file存在且是一个名字管道（F如果O）则为真<br>管道是linux里面进程间通信的一种方式，其他的还有像信号（signal）、信号量、消息队列、共享内存、套接字（socket）等。</p><p>[-r file] 如果file存在且是可读的则为真 </p><p>[-s file] 如果file存在且大小不为0则为真</p><p>[-t FD] 如果文件描述符FD打开且指向一个终端则为真 </p><p>[-u file] 如果file存在且设置了SUID（set userID）则为真 </p><p>[-w file] 如果file存在且是可写的则为真</p><p>[-x file] 如果file存在且是可执行的则为真</p><p>[-O file] 如果file存在且属有效用户ID则为真 </p><p>[-G file] 如果file存在且属有效用户组则为真 </p><p>[-L file] 如果file存在且是一个符号连接则为真 </p><p>[-N file] 如果file存在and has been mod如果ied since it was last read则为真 </p><p>[-S file] 如果file存在且是一个套接字则为真 </p><p>[file1 –nt file2] 如果file1 has been changed more recently than file2或者file1 exists and file2 does not则为真 </p><p>[file1 –ot file2] 如果file1比file2要老，或者file2存在且file1不存在则为真 </p><p>[file1 –ef file2] 如果file1和file2指向相同的设备和节点号则为真 </p><p>[-o optionname] 如果shell选项“optionname”开启则为真 </p><p>[-z string] “string”的长度为零则为真 </p><p>[-n string] or [string] “string”的长度为非零non-zero则为真 </p><p>[sting1==string2] 如果2个字符串相同。“=”may be used instead of “==”for strict posix compliance则为真 </p><p>[string1!=string2] 如果字符串不相等则为真<br>[string1&lt;string2] 如果“string1”sorts before“string2”lexicographically in the current locale则为真</p><p>[arg1 OP arg2] “OP”is one of –eq,-ne,-lt,-le,-gt or –ge.These arithmetic binary oprators return true if “arg1”is equal to,not equal to,less than,less than or equal to,greater than,or greater than or equal to“agr2”,respectively.“arg1”and “agr2”are integers. </p><p>参考资料<br><a href="http://blog.csdn.net/vergilgeekopen/article/details/69493321" target="_blank" rel="noopener">http://blog.csdn.net/vergilgeekopen/article/details/69493321</a></p><h3 id="有问题可以联系博主。"><a href="#有问题可以联系博主。" class="headerlink" title="有问题可以联系博主。"></a><strong>有问题可以联系博主</strong>。</h3><h3 id="转载请注明出处，谢谢！"><a href="#转载请注明出处，谢谢！" class="headerlink" title="转载请注明出处，谢谢！"></a><strong>转载请注明出处，谢谢</strong>！</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;shell中条件判断if中的-a到-z的意思&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://luojiamingl.github.io/categories/linux/"/>
    
    
      <category term="shell" scheme="http://luojiamingl.github.io/tags/shell/"/>
    
      <category term="linux" scheme="http://luojiamingl.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux中date命令的各种实用方法</title>
    <link href="http://luojiamingl.github.io/2018/01/10/Linux%E4%B8%ADdate%E5%91%BD%E4%BB%A4%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://luojiamingl.github.io/2018/01/10/Linux中date命令的各种实用方法/</id>
    <published>2018-01-10T11:59:22.000Z</published>
    <updated>2018-04-11T11:03:33.644Z</updated>
    
    <content type="html"><![CDATA[<p> Linux中date命令的各种实用方法</p><a id="more"></a><p>用法：date [选项]… [+格式]<br>　或：date [-u|–utc|–universal] [MMDDhhmm[[CC]YY][.ss]]<br>以给定的格式显示当前时间，或是设置系统日期。</p><p>  -d,–date=字符串              显示指定字符串所描述的时间，而非当前时间</p><p>  -f,–file=日期文件            类似–date，从日期文件中按行读入时间描述</p><p>  -r, –reference=文件          显示文件指定文件的最后修改时间</p><p>  -s, –set=字符串              设置指定字符串来分开时间</p><p>  -u, –utc, –universal        输出或者设置协调的通用时间<br>      –help            显示此帮助信息并退出<br>      –version         显示版本信息并退出</p><p>读者可以设定特定的格式，格式设定规则：一个加号后接数个标记，每个标记中都有%，其中可用的标记列表和说明如下:</p><p>%n : 下一行</p><p>%t : 跳格</p><p>%H : 小时(00..23)</p><p>%I : 小时(01..12)</p><p>%k : 小时(0..23)</p><p>%l : 小时(1..12)</p><p>%M : 分钟(00..59)</p><p>%p : 显示本地 AM 或 PM</p><p>%r : 直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)</p><p>%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数<br>%S : 秒(00..59)</p><p>%T : 直接显示时间 (24 小时制)</p><p>%X : 相当于 %H:%M:%S</p><p>%Z : 显示时区 %a : 星期几 (Sun..Sat)</p><p>%A : 星期几<br>(Sunday..Saturday)</p><p>%b : 月份 (Jan..Dec)</p><p>%B : 月份 (January..December)</p><p>%c : 直接显示日期与时间</p><p>%d : 日 (01..31)</p><p>%D : 直接显示日期 (mm/dd/yy)</p><p>%h : 同 %b</p><p>%j : 一年中的第几天 (001..366)</p><p>%m : 月份 (01..12)</p><p>%U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形)</p><p>%w : 一周中的第几天 (0..6)</p><p>%W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形)</p><p>%x : 直接显示日期 (mm/dd/yy)</p><p>%y : 年份的最后两位数字 (00.99)</p><p>%Y : 完整年份 (0000..9999)</p><p>##1.按照特定的格式输出时间：短接符”-“、空格” “和冒号”:” 为分隔符，其中空格前面加了转义符号”\”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@RHEL601 tmp]# date +%Y-%m-%d\ %H:%M:%S</span><br><span class="line">2012-07-19 21:10:28</span><br></pre></td></tr></table></figure><p>在当前时间的基础上往前推或者往后推三天<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@RHEL601 tmp]# date -d &quot;+3 day&quot; </span><br><span class="line">2012年 07月 22日 星期日 20:12:08 CST</span><br><span class="line">[root@RHEL601 tmp]# date -d &quot;-3 day&quot;  </span><br><span class="line">2012年 07月 16日 星期一 20:12:12 CST</span><br></pre></td></tr></table></figure></p><p>在当前时间的基础上往前推或者往后推三个月<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@RHEL601 tmp]# date -d &quot;-3 month&quot;    </span><br><span class="line">2012年 04月 19日 星期四 20:12:39 CST</span><br><span class="line">[root@RHEL601 tmp]# date -d &quot;+3 month&quot;  </span><br><span class="line">2012年 10月 19日 星期五 20:12:48 CST</span><br></pre></td></tr></table></figure></p><p>在当前时间的基础上往前推或者往后推三年<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@RHEL601 tmp]# date -d &quot;+3 year&quot;      </span><br><span class="line">2015年 07月 19日 星期日 20:13:06 CST</span><br><span class="line">[root@RHEL601 tmp]# date -d &quot;-3 year&quot;   </span><br><span class="line">2009年 07月 19日 星期日 20:13:11 CST</span><br></pre></td></tr></table></figure></p><p>在当前时间的基础上往前推或者往后推三小时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@RHEL601 tmp]# date -d &quot;-3 hour&quot;     </span><br><span class="line">2012年 07月 19日 星期四 17:13:20 CST</span><br><span class="line">[root@RHEL601 tmp]# date -d &quot;+3 hour&quot;  </span><br><span class="line">2012年 07月 19日 星期四 23:13:24 CST</span><br></pre></td></tr></table></figure></p><p>在当前时间的基础上往前推或者往后推三分钟<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@RHEL601 tmp]# date -d &quot;+3 minute&quot;       </span><br><span class="line">2012年 07月 19日 星期四 20:16:56 CST</span><br><span class="line">[root@RHEL601 tmp]# date -d &quot;-3 minute&quot;  </span><br><span class="line">2012年 07月 19日 星期四 20:10:59 CST</span><br></pre></td></tr></table></figure></p><p>在当前时间的基础上往前推或者往后推三十秒<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@RHEL601 tmp]# date &amp;&amp; date -d &quot;-30 second&quot;         </span><br><span class="line">2012年 07月 19日 星期四 20:14:24 CST</span><br><span class="line">2012年 07月 19日 星期四 20:13:54 CST</span><br><span class="line">[root@RHEL601 tmp]# date &amp;&amp; date -d &quot;+30 second&quot;  </span><br><span class="line">2012年 07月 19日 星期四 20:14:29 CST</span><br><span class="line">2012年 07月 19日 星期四 20:14:59 CST</span><br></pre></td></tr></table></figure></p><p>##2、接下来的范例说明如何用date来表示各种各样的时间，表示的都是某一天的零点时间，也可以在当前的时分秒的基础上表示时间，(特别注意中间用到了反单引号`)参见范例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">date -d `date +%y%m01` #本月第一天</span><br><span class="line">[root@RHEL601 tmp]# date -d `date +%y%m01`</span><br><span class="line">2012年 07月 01日 星期日 00:00:00 CST</span><br><span class="line"></span><br><span class="line">date -d `date +%y%m01`&quot;-1 day&quot;  #上个月最后一天</span><br><span class="line">[root@RHEL601 tmp]# date -d `date +%y%m01`&quot;-1 day&quot;</span><br><span class="line">2012年 06月 30日 星期六 00:00:00 CST</span><br><span class="line"></span><br><span class="line">date -d `date -d &quot;-3 month&quot; +%y%m01`&quot;-1 day&quot; #4个月前的第一天</span><br><span class="line">[root@RHEL601 tmp]# date -d `date -d &quot;-3 month&quot; +%y%m01`&quot;-1 day&quot;</span><br><span class="line">2012年 03月 31日 星期六 00:00:00 CST</span><br><span class="line"></span><br><span class="line">date -d `date -d &quot;+12 month&quot; +%y%m01`&quot;-1 day&quot; #第11个月后的第一天</span><br><span class="line">[root@RHEL601 tmp]# date -d `date -d &quot;+12 month&quot; +%y%m01`&quot;-1 day&quot;</span><br><span class="line">2013年 06月 30日 星期日 00:00:00 CST</span><br><span class="line"></span><br><span class="line">date -d `date -d &quot;-1 month&quot; +%y%m01` #上个月第一天</span><br><span class="line">[root@RHEL601 tmp]# date -d `date -d &quot;-1 month&quot; +%y%m01`</span><br><span class="line">2012年 06月 01日 星期五 00:00:00 CST</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">date -d `date -d &quot;+12 month&quot; +%y%m01` #第12个月后的第一天</span><br><span class="line">[root@RHEL601 tmp]# date -d `date -d &quot;+12 month&quot; +%y%m01`</span><br><span class="line">2013年 07月 01日 星期一 00:00:00 CST</span><br><span class="line"></span><br><span class="line">date -d `date -d &quot;-1 day&quot; +%Y%m%d` #前一天零点时间</span><br><span class="line">[root@RHEL601 tmp]# date -d `date -d &quot;-1 day&quot; +%Y%m%d`</span><br><span class="line">2012年 07月 18日 星期三 00:00:00 CST</span><br><span class="line"></span><br><span class="line">date -d `date -d &quot;-3 day&quot; +%Y%m%d` #前三天零点时间</span><br><span class="line">[root@RHEL601 tmp]# date -d `date -d &quot;-3 day&quot; +%Y%m%d` </span><br><span class="line">2012年 07月 16日 星期一 00:00:00 CST</span><br><span class="line"></span><br><span class="line">date -d `date -d &quot;+1 day&quot; +%Y%m%d` #明天零点时间</span><br><span class="line">[root@RHEL601 tmp]# date -d `date -d &quot;+1 day&quot; +%Y%m%d`  </span><br><span class="line">2012年 07月 20日 星期五 00:00:00 CST</span><br><span class="line"></span><br><span class="line">date -d `date -d &quot;+3 day&quot; +%Y%m%d` #往后推三天零点时间</span><br><span class="line">[root@RHEL601 tmp]# date -d `date -d &quot;+3 day&quot; +%Y%m%d` </span><br><span class="line">2012年 07月 22日 星期日 00:00:00 CST</span><br></pre></td></tr></table></figure></p><p>##3、以下简单示范了字母大小写在date命令中的区别<br>Y #代表完整的年份，例如:2012年 将显示 2012<br>y #代表缩写年份，例如：2012年 缩写为 12<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@RHEL601 tmp]# date +&quot;%y%m01%H%M%S&quot;</span><br><span class="line">121201121556</span><br><span class="line">[root@RHEL601 tmp]# date +&quot;%Y%m01%H%M%S&quot;</span><br><span class="line">20121201121610</span><br></pre></td></tr></table></figure></p><p>##4、以下范例说明如何调整服务器的时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntpdate 210.72.145.44</span><br></pre></td></tr></table></figure></p><p>将服务器时间调整为正常时间，210.72.145.44 是国家授时中心服务器IP地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@RHEL601 tmp]# ntpdate 210.72.145.44</span><br><span class="line">19 Jul 13:07:07 ntpdate[15150]: adjust time server 210.72.145.44 offset -0.020920 sec</span><br></pre></td></tr></table></figure></p><p>date 121212122012</p><p>将时间设置为2012年 12月 12日 星期三 12:12:00，date后面的数字代表月日时分年，还可以加秒，需要后面跟英文状态下的句号字符”.”，例如：121212122012.12<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@RHEL601 tmp]# date 121212122012</span><br><span class="line">2012年 12月 12日 星期三 12:12:00 CST</span><br><span class="line">[root@RHEL601 tmp]# date 121212122012.12</span><br><span class="line">2012年 12月 12日 星期三 12:12:12 CST</span><br><span class="line"></span><br><span class="line">[root@RHEL601 tmp]# date `date -d &quot;1 day ago&quot; +%m%d%H%M%Y.%S`</span><br><span class="line">2012年 07月 18日 星期三 20:13:04 CST</span><br><span class="line">[root@RHEL601 tmp]# date</span><br><span class="line">2012年 07月 18日 星期三 20:13:10 CST</span><br><span class="line">[root@RHEL601 tmp]# date `date -d &quot;3 days ago&quot; +%m%d%H%M%Y.%S`</span><br><span class="line">2012年 07月 15日 星期日 20:13:18 CST</span><br><span class="line">[root@RHEL601 tmp]# date `date -d &quot;5 days ago&quot; +%m%d%H%M%Y.%S`</span><br><span class="line">2012年 07月 10日 星期二 20:13:28 CST</span><br><span class="line">[root@RHEL601 tmp]# date `date -d &quot;$((3600*24)) seconds ago&quot; +%m%d%H%M%Y.%S`</span><br><span class="line">2012年 07月 09日 星期一 20:13:39 CST</span><br><span class="line">[root@RHEL601 tmp]# date `date -d &quot;$((3600*24)) seconds ago&quot; +%m%d%H%M%Y.%S`</span><br><span class="line">2012年 07月 08日 星期日 20:14:01 CST</span><br><span class="line">[root@RHEL601 tmp]# ntpdate 210.72.145.44</span><br><span class="line">19 Jul 20:14:15 ntpdate[26846]: step time server 210.72.145.44 offset 950404.037565 sec</span><br></pre></td></tr></table></figure></p><p>参考资料<br><a href="http://blog.chinaunix.net/uid-22823163-id-3293784.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-22823163-id-3293784.html</a></p><h3 id="有问题可以联系博主。"><a href="#有问题可以联系博主。" class="headerlink" title="有问题可以联系博主。"></a><strong>有问题可以联系博主</strong>。</h3><h3 id="转载请注明出处，谢谢！"><a href="#转载请注明出处，谢谢！" class="headerlink" title="转载请注明出处，谢谢！"></a><strong>转载请注明出处，谢谢</strong>！</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; Linux中date命令的各种实用方法&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://luojiamingl.github.io/categories/linux/"/>
    
    
      <category term="shell" scheme="http://luojiamingl.github.io/tags/shell/"/>
    
      <category term="linux" scheme="http://luojiamingl.github.io/tags/linux/"/>
    
  </entry>
  
</feed>
