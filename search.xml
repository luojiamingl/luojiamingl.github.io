<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux中date命令的各种实用方法]]></title>
    <url>%2F2018%2F01%2F10%2FLinux%E4%B8%ADdate%E5%91%BD%E4%BB%A4%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Linux中date命令的各种实用方法 用法：date [选项]… [+格式] 或：date [-u|–utc|–universal] [MMDDhhmm[[CC]YY][.ss]]以给定的格式显示当前时间，或是设置系统日期。 -d,–date=字符串 显示指定字符串所描述的时间，而非当前时间 -f,–file=日期文件 类似–date，从日期文件中按行读入时间描述 -r, –reference=文件 显示文件指定文件的最后修改时间 -s, –set=字符串 设置指定字符串来分开时间 -u, –utc, –universal 输出或者设置协调的通用时间 –help 显示此帮助信息并退出 –version 显示版本信息并退出 读者可以设定特定的格式，格式设定规则：一个加号后接数个标记，每个标记中都有%，其中可用的标记列表和说明如下: %n : 下一行 %t : 跳格 %H : 小时(00..23) %I : 小时(01..12) %k : 小时(0..23) %l : 小时(1..12) %M : 分钟(00..59) %p : 显示本地 AM 或 PM %r : 直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M) %s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数%S : 秒(00..59) %T : 直接显示时间 (24 小时制) %X : 相当于 %H:%M:%S %Z : 显示时区 %a : 星期几 (Sun..Sat) %A : 星期几(Sunday..Saturday) %b : 月份 (Jan..Dec) %B : 月份 (January..December) %c : 直接显示日期与时间 %d : 日 (01..31) %D : 直接显示日期 (mm/dd/yy) %h : 同 %b %j : 一年中的第几天 (001..366) %m : 月份 (01..12) %U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形) %w : 一周中的第几天 (0..6) %W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形) %x : 直接显示日期 (mm/dd/yy) %y : 年份的最后两位数字 (00.99) %Y : 完整年份 (0000..9999) ##1.按照特定的格式输出时间：短接符”-“、空格” “和冒号”:” 为分隔符，其中空格前面加了转义符号”\” 12[root@RHEL601 tmp]# date +%Y-%m-%d\ %H:%M:%S2012-07-19 21:10:28 在当前时间的基础上往前推或者往后推三天1234[root@RHEL601 tmp]# date -d &quot;+3 day&quot; 2012年 07月 22日 星期日 20:12:08 CST[root@RHEL601 tmp]# date -d &quot;-3 day&quot; 2012年 07月 16日 星期一 20:12:12 CST 在当前时间的基础上往前推或者往后推三个月1234[root@RHEL601 tmp]# date -d &quot;-3 month&quot; 2012年 04月 19日 星期四 20:12:39 CST[root@RHEL601 tmp]# date -d &quot;+3 month&quot; 2012年 10月 19日 星期五 20:12:48 CST 在当前时间的基础上往前推或者往后推三年1234[root@RHEL601 tmp]# date -d &quot;+3 year&quot; 2015年 07月 19日 星期日 20:13:06 CST[root@RHEL601 tmp]# date -d &quot;-3 year&quot; 2009年 07月 19日 星期日 20:13:11 CST 在当前时间的基础上往前推或者往后推三小时1234[root@RHEL601 tmp]# date -d &quot;-3 hour&quot; 2012年 07月 19日 星期四 17:13:20 CST[root@RHEL601 tmp]# date -d &quot;+3 hour&quot; 2012年 07月 19日 星期四 23:13:24 CST 在当前时间的基础上往前推或者往后推三分钟1234[root@RHEL601 tmp]# date -d &quot;+3 minute&quot; 2012年 07月 19日 星期四 20:16:56 CST[root@RHEL601 tmp]# date -d &quot;-3 minute&quot; 2012年 07月 19日 星期四 20:10:59 CST 在当前时间的基础上往前推或者往后推三十秒123456[root@RHEL601 tmp]# date &amp;&amp; date -d &quot;-30 second&quot; 2012年 07月 19日 星期四 20:14:24 CST2012年 07月 19日 星期四 20:13:54 CST[root@RHEL601 tmp]# date &amp;&amp; date -d &quot;+30 second&quot; 2012年 07月 19日 星期四 20:14:29 CST2012年 07月 19日 星期四 20:14:59 CST ##2、接下来的范例说明如何用date来表示各种各样的时间，表示的都是某一天的零点时间，也可以在当前的时分秒的基础上表示时间，(特别注意中间用到了反单引号`)参见范例12345678910111213141516171819202122232425262728293031323334353637383940date -d `date +%y%m01` #本月第一天[root@RHEL601 tmp]# date -d `date +%y%m01`2012年 07月 01日 星期日 00:00:00 CSTdate -d `date +%y%m01`&quot;-1 day&quot; #上个月最后一天[root@RHEL601 tmp]# date -d `date +%y%m01`&quot;-1 day&quot;2012年 06月 30日 星期六 00:00:00 CSTdate -d `date -d &quot;-3 month&quot; +%y%m01`&quot;-1 day&quot; #4个月前的第一天[root@RHEL601 tmp]# date -d `date -d &quot;-3 month&quot; +%y%m01`&quot;-1 day&quot;2012年 03月 31日 星期六 00:00:00 CSTdate -d `date -d &quot;+12 month&quot; +%y%m01`&quot;-1 day&quot; #第11个月后的第一天[root@RHEL601 tmp]# date -d `date -d &quot;+12 month&quot; +%y%m01`&quot;-1 day&quot;2013年 06月 30日 星期日 00:00:00 CSTdate -d `date -d &quot;-1 month&quot; +%y%m01` #上个月第一天[root@RHEL601 tmp]# date -d `date -d &quot;-1 month&quot; +%y%m01`2012年 06月 01日 星期五 00:00:00 CSTdate -d `date -d &quot;+12 month&quot; +%y%m01` #第12个月后的第一天[root@RHEL601 tmp]# date -d `date -d &quot;+12 month&quot; +%y%m01`2013年 07月 01日 星期一 00:00:00 CSTdate -d `date -d &quot;-1 day&quot; +%Y%m%d` #前一天零点时间[root@RHEL601 tmp]# date -d `date -d &quot;-1 day&quot; +%Y%m%d`2012年 07月 18日 星期三 00:00:00 CSTdate -d `date -d &quot;-3 day&quot; +%Y%m%d` #前三天零点时间[root@RHEL601 tmp]# date -d `date -d &quot;-3 day&quot; +%Y%m%d` 2012年 07月 16日 星期一 00:00:00 CSTdate -d `date -d &quot;+1 day&quot; +%Y%m%d` #明天零点时间[root@RHEL601 tmp]# date -d `date -d &quot;+1 day&quot; +%Y%m%d` 2012年 07月 20日 星期五 00:00:00 CSTdate -d `date -d &quot;+3 day&quot; +%Y%m%d` #往后推三天零点时间[root@RHEL601 tmp]# date -d `date -d &quot;+3 day&quot; +%Y%m%d` 2012年 07月 22日 星期日 00:00:00 CST ##3、以下简单示范了字母大小写在date命令中的区别Y #代表完整的年份，例如:2012年 将显示 2012y #代表缩写年份，例如：2012年 缩写为 121234[root@RHEL601 tmp]# date +&quot;%y%m01%H%M%S&quot;121201121556[root@RHEL601 tmp]# date +&quot;%Y%m01%H%M%S&quot;20121201121610 ##4、以下范例说明如何调整服务器的时间1ntpdate 210.72.145.44 将服务器时间调整为正常时间，210.72.145.44 是国家授时中心服务器IP地址12[root@RHEL601 tmp]# ntpdate 210.72.145.4419 Jul 13:07:07 ntpdate[15150]: adjust time server 210.72.145.44 offset -0.020920 sec date 121212122012 将时间设置为2012年 12月 12日 星期三 12:12:00，date后面的数字代表月日时分年，还可以加秒，需要后面跟英文状态下的句号字符”.”，例如：121212122012.1212345678910111213141516171819[root@RHEL601 tmp]# date 1212121220122012年 12月 12日 星期三 12:12:00 CST[root@RHEL601 tmp]# date 121212122012.122012年 12月 12日 星期三 12:12:12 CST[root@RHEL601 tmp]# date `date -d &quot;1 day ago&quot; +%m%d%H%M%Y.%S`2012年 07月 18日 星期三 20:13:04 CST[root@RHEL601 tmp]# date2012年 07月 18日 星期三 20:13:10 CST[root@RHEL601 tmp]# date `date -d &quot;3 days ago&quot; +%m%d%H%M%Y.%S`2012年 07月 15日 星期日 20:13:18 CST[root@RHEL601 tmp]# date `date -d &quot;5 days ago&quot; +%m%d%H%M%Y.%S`2012年 07月 10日 星期二 20:13:28 CST[root@RHEL601 tmp]# date `date -d &quot;$((3600*24)) seconds ago&quot; +%m%d%H%M%Y.%S`2012年 07月 09日 星期一 20:13:39 CST[root@RHEL601 tmp]# date `date -d &quot;$((3600*24)) seconds ago&quot; +%m%d%H%M%Y.%S`2012年 07月 08日 星期日 20:14:01 CST[root@RHEL601 tmp]# ntpdate 210.72.145.4419 Jul 20:14:15 ntpdate[26846]: step time server 210.72.145.44 offset 950404.037565 sec 参考资料http://blog.chinaunix.net/uid-22823163-id-3293784.html 有问题可以联系博主，博客主页有邮箱，微博，文章底部有微信公众号等联系方式。 转载请注明出处，谢谢！]]></content>
      <categories>
        <category>编程</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>脚本</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell 输出重定向（> >> 2>&1）]]></title>
    <url>%2F2018%2F01%2F10%2Fshell%20%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%88%3E%20%3E%3E%202%3E%261%EF%BC%89%2F</url>
    <content type="text"><![CDATA[shell - 输出重定向（&gt; &gt;&gt; 2&gt;&amp;1） 一、bash中0，1，2bash中0，1，2三个数字分别代表STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO，即标准输入（一般是键盘），标准输出（一般是显示屏，准确的说是用户终端控制台），标准错误（出错信息输出） 二、输入输出重定向所谓重定向输入就是在命令中指定具体的输入来源，譬如 cat &lt; test.c 将test.c重定向为cat命令的输入源。输出重定向是指定具体的输出目标以替换默认的标准输出，譬如ls &gt; 1.txt将ls的结果从标准输出重定向为1.txt文本。有时候会看到如 ls &gt;&gt; 1.txt这类的写法，&gt; 和 &gt;&gt; 的区别在于：&gt; 用于新建而&gt;&gt;用于追加。即ls &gt; 1.txt会新建一个1.txt文件并且将ls的内容输出到新建的1.txt中，而ls &gt;&gt; 1.txt则用在1.txt已经存在，而我们只是想将ls的内容追加到1.txt文本中的时候。 默认输入只有一个（0，STDIN_FILENO），而默认输出有两个（标准输出1 STDOUT_FILENO，标准错误2 STDERR_FILENO）。因此默认情况下，shell输出的错误信息会被输出到2，而普通输出信息会输出到1。但是某些情况下，我们希望在一个终端下看到所有的信息（包括标准输出信息和错误信息），要怎么办呢？对了，你可以使用我们上面讲到的输出重定向。思路有了，怎么写呢？ 非常直观的想法就是2&gt;1（将2重定向到1嘛），行不行呢？试一试就知道了。我们进行以下测试步骤： 123451）mkdir test &amp;&amp; cd test; 创建test文件夹并进入test目录2）touch a.txt b.c c; 创建a.txt b.c c 三个文件3）ls &gt; 1; 按我们的猜测，这句应该是将ls的结果重定向到标准输出，因此效果和直接ls应该一样。但是实际这句执行后，标准输出中并没有任何信息。4）ls; 执行3之后再次ls，则会看到test文件夹中多了一个文件15）cat 1 ; 查看文件1的内容，实际结果为：1 a.txt b.c c 可见步骤3中 ls &gt; 1并不是将ls的结果重定向为标准输出，而是将结果重定向到了一个文件1中。即1在此处不被解释为STDOUT_FILENO，而是文件1。 4、到了此时，你应该也能猜到2&gt;&amp;1的用意了。不错，2&gt;&amp;1就是用来将标准错误2重定向到标准输出1中的。此处1前面的&amp;就是为了让bash将1解释成标准输出而不是文件1。至于最后一个&amp;，则是让bash在后台执行 三、例子🌰1.输出重定向 1.1把标准输出重定向到文件 1234567[~]# echo &quot;hello&quot; &gt; test.sh[~]# cat test.shhello&apos;&gt;&apos;输出方式默认等价&apos;1&gt;&apos;[~]# echo &quot;hello&quot; 1&gt; test.sh[~]# cat test.shhello 输入、输出及标准错误输出主要用于 I/O 的重定向，就是说需要改变他们的默认设置。先看这个例子：1$ ls &gt; ls_result $ ls -l &gt;&gt; ls_result 上面这两个命令分别将 ls 命令的结果输出重定向到 ls_result 文件中和追加到 ls_result 文件中，而不是输出到屏幕上。”&gt;”就是输出（标准输出和标准错误输出）重定向的代表符号，连续两个 “&gt;” 符号，即 “&gt;&gt;” 则表示不清除原来的而追加输出。下面再来看一个稍微复杂的例子：1$ find /home -name lost* 2&gt; err_result 这个命令在 “&gt;” 符号之前多了一个 “2”，”2&gt;” 表示将标准错误输出重定向。由于 /home 目录下有些目录由于权限限制不能访问，因此会产生一些标准错误输出被存放在 err_result 文件中。 大家可以设想一下 find /home -name lost 2&gt;&gt;err_result 命令会产生什么结果？如果直接执行 find /home -name lost &gt; all_result ，其结果是只有标准输出被存入 all_result 文件中，要想让标准错误输出和标准输入一样都被存入到文件中，那该怎么办呢？看下面这个例子：1$ find /home -name lost* &gt; all_result 2&gt;&amp; 1 上面这个例子中将首先将标准错误输出也重定向到标准输出中，再将标准输出重定向到 all_result 这个文件中。这样我们就可以将所有的输出都存储到文件中了。为实现上述功能，还有一种简便的写法如下：1$ find /home -name lost* &gt;&amp; all_result 如果那些出错信息并不重要，下面这个命令可以让你避开众多无用出错信息的干扰：1$ find /home -name lost* 2&gt; /dev/null 同学们回去后还可以再试验一下如下几种重定向方式，看看会出什么结果，为什么？1$ find /home -name lost* &gt; all_result 1&gt;&amp; 2 $ find /home -name lost* 2&gt; all_result 1&gt;&amp; 2 $ find /home -name lost* 2&gt;&amp; 1 &gt; all_result 另外一个非常有用的重定向操作符是 “-“，请看下面这个例子1$ (cd /source/directory &amp;&amp; tar cf - . ) | (cd /dest/directory &amp;&amp; tar xvfp -) 该命令表示把 /source/directory 目录下的所有文件通过压缩和解压，快速的全部移动到 /dest/directory 目录下去，这个命令在 /source/directory 和 /dest/directory 不处在同一个文件系统下时将显示出特别的优势。下面还几种不常见的用法：n&lt;&amp;- 表示将 n 号输入关闭 &lt;&amp;- 表示关闭标准输入（键盘） n&gt;&amp;- 表示将 n 号输出关闭 &gt;&amp;- 表示将标准输出关闭 参考资料http://qinqianshan.com/shell-output-redirection-21/ http://blog.csdn.net/feng27156/article/details/38980543 有问题可以联系博主，博客主页有邮箱，微博，文章底部有微信公众号等联系方式。 转载请注明出处，谢谢！]]></content>
      <categories>
        <category>编程 - linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>脚本</tag>
        <tag>重定向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell中条件判断if中的-a到-z的意思]]></title>
    <url>%2F2018%2F01%2F10%2Fshell%E4%B8%AD%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%ADif%E4%B8%AD%E7%9A%84-a%E5%88%B0-z%E7%9A%84%E6%84%8F%E6%80%9D%2F</url>
    <content type="text"><![CDATA[shell中条件判断if中的-a到-z的意思 [-a file] 如果file存在则为真 [-b file] 如果file存在且是一个块特殊文件则为真 [-c file] 如果file存在且是一个字特殊文件则为真 [-d file] 如果file文件存在且是一个目录则为真-d前的!是逻辑非例如：1if [ ! -d $lcd_path/$par_date ] 表示后面的那个目录不存在，则执行后面的then操作 [-e file] 如果file文件存在则为真 [-f file] 如果file存在且是一个普通文件则为真 [-g file] 如果file存在且已经设置了SGID则为真（SUID 是 Set User ID, SGID 是 Set Group ID的意思） [-h file] 如果file存在且是一个符号连接则为真 [-k file] 如果file存在且已经设置粘制位则为真当一个目录被设置为”粘制位”(用chmod a+t),则该目录下的文件只能由一、超级管理员删除二、该目录的所有者删除三、该文件的所有者删除也就是说,即便该目录是任何人都可以写,但也只有文件的属主才可以删除文件。具体例子如下：123#ls -dl /tmp drwxrwxrwt 4 root root ......... 注意other位置的t，这便是粘连位。 [-p file] 如果file存在且是一个名字管道（F如果O）则为真管道是linux里面进程间通信的一种方式，其他的还有像信号（signal）、信号量、消息队列、共享内存、套接字（socket）等。 [-r file] 如果file存在且是可读的则为真 [-s file] 如果file存在且大小不为0则为真 [-t FD] 如果文件描述符FD打开且指向一个终端则为真 [-u file] 如果file存在且设置了SUID（set userID）则为真 [-w file] 如果file存在且是可写的则为真 [-x file] 如果file存在且是可执行的则为真 [-O file] 如果file存在且属有效用户ID则为真 [-G file] 如果file存在且属有效用户组则为真 [-L file] 如果file存在且是一个符号连接则为真 [-N file] 如果file存在and has been mod如果ied since it was last read则为真 [-S file] 如果file存在且是一个套接字则为真 [file1 –nt file2] 如果file1 has been changed more recently than file2或者file1 exists and file2 does not则为真 [file1 –ot file2] 如果file1比file2要老，或者file2存在且file1不存在则为真 [file1 –ef file2] 如果file1和file2指向相同的设备和节点号则为真 [-o optionname] 如果shell选项“optionname”开启则为真 [-z string] “string”的长度为零则为真 [-n string] or [string] “string”的长度为非零non-zero则为真 [sting1==string2] 如果2个字符串相同。“=”may be used instead of “==”for strict posix compliance则为真 [string1!=string2] 如果字符串不相等则为真[string1&lt;string2] 如果“string1”sorts before“string2”lexicographically in the current locale则为真 [arg1 OP arg2] “OP”is one of –eq,-ne,-lt,-le,-gt or –ge.These arithmetic binary oprators return true if “arg1”is equal to,not equal to,less than,less than or equal to,greater than,or greater than or equal to“agr2”,respectively.“arg1”and “agr2”are integers. 参考资料http://blog.csdn.net/vergilgeekopen/article/details/69493321 有问题可以联系博主，博客主页有邮箱，微博，文章底部有微信公众号等联系方式。 转载请注明出处，谢谢！]]></content>
      <categories>
        <category>编程 - linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>脚本</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime注册码破解及关闭自动更新]]></title>
    <url>%2F2017%2F09%2F30%2Fsublime%E7%A0%B4%E8%A7%A3%E5%8F%8A%E5%85%B3%E9%97%AD%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[sublime - 丰富的文本编辑器，使用技巧 破解方法话不多说，先分享三个注册码！点击最右侧 help add license，添加注册码即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354—– BEGIN LICENSE —–Michael BarnesSingle User LicenseEA7E-8213858A353C41 872A0D5C DF9B2950 AFF6F667C458EA6D 8EA3C286 98D1D650 131A97ABAA919AEC EF20E143 B361B1E7 4C8B7F04B085E65E 2F5F5360 8489D422 FB8FC1AA93F6323C FD7F7544 3F39C318 D95E6480FCCC7561 8A4A1741 68FA4223 ADCEDE07200C25BE DBBC4855 C4CFB774 C5EC138C0FEC1CEF D9DCECEC D3A5DAD1 01316C36—— END LICENSE ———– BEGIN LICENSE —–Nicolas HennionSingle User LicenseEA7E-8660758A01AA83 1D668D24 4484AEBC 3B04512C827B0DE5 69E9B07A A39ACCC0 F95F5410729D5639 4C37CECB B2522FB3 8D37FDC172899363 BBA441AC A5F47F08 6CD3B3FECEFB3783 B2E1BA96 71AAF7B4 AFB61B1D0CC513E7 52FF2333 9F726D2C CDE53B4A810C0D4F E1F419A3 CDA0832B 8440565A35BF00F6 4CA9F869 ED10E245 469C233E—— END LICENSE ———– BEGIN LICENSE —–Anthony SansoneSingle User LicenseEA7E-87856328B9A648 42B99D8A F2E3E9E0 16DE076EE218B3DC F3606379 C33C1526 E8B58964B2CB3F63 BDF901BE D31424D2 082891B5F7058694 55FA46D8 EFC11878 0868F093B17CAFE7 63A78881 86B78E38 0F146238BAE22DBB D4EC71A1 0EC2E701 C7F9C6485CF29CA3 1CB14285 19A46991 E9A9867614FD4777 2D8A0AB6 A444EE0D CA009B54—— END LICENSE ———– BEGIN LICENSE —–Alexey PlutalovSingle User LicenseEA7E-8607763DC19CC1 134CDF23 504DC871 2DE5CE55585DC8A6 253BB0D9 637C87A2 D8D0BA85AAE574AD BA7D6DA9 2B9773F2 324C5DEF17830A4E FBCF9D1D 182406E9 F883EA87E585BBA1 2538C270 E2E857C2 194283CA7234FF9E D0392F93 1D16E021 F191491763909E12 203C0169 3F08FFC8 86D06EA873DDAEF0 AC559F30 A6A67947 B60104C6—— END LICENSE —— 关闭自动更新如图打开,添加如下代码12345// Settings in here override those in &quot;Default/Preferences.sublime-settings&quot;,// and are overridden in turn by file type specific settings.&#123; &quot;update_check&quot; : false&#125; 注意：博主添加代码时发现自动更新提醒还是会弹出来，后来发现是没有破解，破解之后就不会弹出来了 转载请注明出处，谢谢！]]></content>
      <categories>
        <category>编程</category>
        <category>软件破解</category>
      </categories>
      <tags>
        <tag>sublime</tag>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础搭建Hexo炫酷静态页面博客]]></title>
    <url>%2F2017%2F09%2F29%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BAHexo%E7%82%AB%E9%85%B7%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo - 快速、简洁且高效的博客框架 GitHubPages + hexo 简介最近花了两天的时间搭建了一个博客，使用GitHubPages + hexo 为什么选用GitHubPages + hexo 优点如下： 1.超快速度Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 2.支持 MarkdownHexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 3.一键部署只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。 4.丰富的插件Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。 博客地址 前期准备github账号node.jsnpmhexo注意：（node.js 集成带有npm，因此只要下载 node.js 就可以了） github上创建GitHubPages仓库GitHubPages官方参考地址 注意： 创建仓库的时候仓库名一定严格按照 git用户名.github.io 来命名创建仓库完成之后，在本地创建一个站点文件夹 git用户名.github.io/blog 下载node.js我是在mac系统上搭建的，下载用的终端brew命令，如果其他系统或者没有翻墙，可能会有问题，如果下载失败可以移步Node.js官网，下载最新版本一路安装即可。检测安装是否成功 终端输入 node -v ,npm -v 成功则显示版本号123➜ blog git:(master) ✗ npm -v5.3.0➜ blog git:(master) ✗ 下载 hexohexo官方 有详细的windows和mac用户的安装文档，如果因为防火墙等原因安装失败，请使用下面命令安装，sudo赋予命令最高权限，避免权限不足 1➜ blog git:(master) sudo npm install hexo --no-optional 下载git文档说明，上面有各个平台的git下载安装步骤，按照步骤安装即可 本地关联github仓库git下载安装完成之后，需要跟你的github仓库关联起来，你需要一个私钥和公钥，首先查看本地有没有1234➜ ~ git:(master) ✗ cd ~/.ssh ➜ .ssh git:(master) ✗ lsconfig id_rsa id_rsa.pub known_hosts➜ .ssh git:(master) ✗ 如果没有id_rsa（私钥）和id_rsa.pub（公钥）就需要手动生成一个，执行命令1➜ ~ git:(master) ✗ ssh-keygen 生成双钥，然后把公钥放到github仓库上，点击头像选择settings左侧找到SSH，然后点击New SSH key，把公钥的文本内容粘贴进去，就可以了 部署hexo命令介绍准备工作完成，就可以部署看一下博客界面效果了,先介绍一下hexo常用命令 hexo clean 清除编辑后生成的静态文件，一般部署前都会执行一遍，防止上次部署结果影响新的文件内容 hexo generate 编辑生成静态页面等 hexo server 启动服务 hexo develop 部署到远程github，需要修改配置文件，稍后介绍 基本上用到的就是这些命令，为了方便可以设置快捷指令，执行如下命令，会在跟目录生成一个.bash_profile文件，同时打开.bash_profile进入编辑模式12➜ ~ git:(master) ✗ cd ~➜ ~ git:(master) ✗ vi .bash_profile 然后输入以下内容,进行保存，linux命令123456789101112131415161718192021222324alias hexo clean=hexo calias hexo generate=hexo galias hexo server=hexo salias hexo develop=hexo d~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ -- INSERT -- 执行如下命令，让文件生效1➜ ~ git:(master) ✗ source .bash_profile 至此，快捷指令设置完成 本地部署然后cd进入本地博客根目录，执行命令12345➜ ~ git:(master) ✗ hexo c➜ ~ git:(master) ✗ hexo d➜ ~ git:(master) ✗ hexo sINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 看到如下信息就可以在本地访问http://localhost:4000/ 查看博客主页了 远程部署部署到元辰github上需要修改一下本地博客配置文件，找到根目录的_config.yml文件，修改以下内容123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:你的github名/你的github名.github.io.git branch: master 然后就可以执行如下命令部署到github1➜ ~ git:(master) ✗ hexo d 看到如下信息说明部署完成，就可以通过https://你的github名.github.io/ 访问你的主页了1INFO Deploy done: git 部署完成至此，一个博客模板搭建完成，hexo还支持丰富的插件，包括RSS订阅，评论系统的接入，文章阅读量，打赏功能，第三方链接，如微博，发邮件等。 接入以上功能，让自己的博客更加炫酷！可以联系博主，博客主页有邮箱，微博，文章底部有微信公众号等联系方式。 转载请注明出处，谢谢！]]></content>
      <categories>
        <category>编程</category>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
